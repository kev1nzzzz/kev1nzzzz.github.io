<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git常用指令</title>
    <url>/git/</url>
    <content><![CDATA[<p>主要是记录git工作流程和归纳一下日常常用的git操作命令，防止遗忘。</p>
<span id="more"></span>

<p>git主要涉及到以下四个关键点：</p>
<p>&emsp;&emsp;<strong>工作区</strong>：本地电脑存放项目文件的地方；</p>
<p>&emsp;&emsp;<strong>暂存区（Index/Stage）</strong>：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版                                                    本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文                                                    件的地方，通常使用add命令将工作区的文件添加到暂存区里；</p>
<p>&emsp;&emsp;<strong>本地仓库：</strong>.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中                          的文件添加到本地仓库中；</p>
<p>&emsp;&emsp;<strong>远程仓库：</strong>不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将                          远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcc0e7e711dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="git几个核心区域间的关系"></p>
<p>所以其实git命令可以划分为以下：</p>
<ol>
<li><strong>git管理配置的命令；</strong></li>
<li><strong>工作区与暂存区的交互；</strong></li>
<li><strong>暂存区与本地仓库（分支）上的交互；</strong></li>
<li><strong>本地仓库与远程仓库的交互。</strong></li>
</ol>
<p>&emsp;</p>
<h2 id="git配置相关"><a href="#git配置相关" class="headerlink" title="git配置相关"></a>git配置相关</h2><ol>
<li><strong>配置用户名和邮箱：</strong></li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;your name&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;youremail@github.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h2 id="工作区上的操作命令"><a href="#工作区上的操作命令" class="headerlink" title="工作区上的操作命令"></a>工作区上的操作命令</h2><h3 id="·-新建仓库"><a href="#·-新建仓库" class="headerlink" title="· 新建仓库"></a><strong>· 新建仓库</strong></h3><ol>
<li><p>将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure></li>
<li><p>从远程git仓库复制项目，克隆项目时如果想定义新的项目名，可以在指令后面指定：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone git:<span class="regexp">//gi</span>thub.com<span class="regexp">/wasd/</span>example.git mygit</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-提交"><a href="#·-提交" class="headerlink" title="· 提交"></a><strong>· 提交</strong></h3><ol>
<li><p>提交工作区所有文件到暂存区</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> .</span><br></pre></td></tr></table></figure></li>
<li><p>提交指定文件到暂存区</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">add</span> <span class="symbol">&lt;file1&gt;</span> <span class="symbol">&lt;file2&gt;</span> ...</span><br></pre></td></tr></table></figure></li>
<li><p>提交工作区中某个文件夹中所有文件到暂存区</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> [dir]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-撤销"><a href="#·-撤销" class="headerlink" title="· 撤销"></a><strong>· 撤销</strong></h3><ol>
<li><p>删除工作区文件，并从暂存区删除对应文件的记录</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> rm &lt;file<span class="number">1</span>&gt; &lt;file<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从暂存区删除文件，但是工作区依然还有该文件</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">rm</span> --cached &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>取消暂存区已经暂存的文件</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">git <span class="meta">reset</span> HEAD &lt;<span class="meta">file</span>&gt;...</span><br></pre></td></tr></table></figure></li>
<li><p>撤销上一次对文件的操作</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">--&lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <em>要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理</em></p>
</li>
</ol>
<h3 id="·-更新文件"><a href="#·-更新文件" class="headerlink" title="· 更新文件"></a><strong>· 更新文件</strong></h3><ol>
<li><p>重命名文件，并将已改名文件提交到暂存区</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git mv [<span class="built_in">file</span>-original] [<span class="built_in">file</span>-renamed]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-查询状态"><a href="#·-查询状态" class="headerlink" title="· 查询状态"></a><strong>· 查询状态</strong></h3><ol>
<li><p>查询当前工作区所有文件的状态</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容(也可以指定文件)</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git diff &lt;<span class="built_in">file</span>-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h2 id="暂存区上的操作命令"><a href="#暂存区上的操作命令" class="headerlink" title="暂存区上的操作命令"></a>暂存区上的操作命令</h2><h3 id="·-提交文件到版本库"><a href="#·-提交文件到版本库" class="headerlink" title="· 提交文件到版本库"></a><strong>· 提交文件到版本库</strong></h3><ol>
<li><p>将暂存区中的文件提交到本地仓库，打上新版本</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&quot;commit_info&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">&quot;commit_info&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-查看信息"><a href="#·-查看信息" class="headerlink" title="· 查看信息"></a><strong>· 查看信息</strong></h3><ol>
<li><p>比较暂存区与上一版本的差异</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git diff &lt;<span class="built_in">file</span>-<span class="built_in">name</span>&gt; <span class="comment">--cached</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看提交历史，参数-p展开每次提交的历史差异，用-2显示最近的两次更新</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p -<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-打标签"><a href="#·-打标签" class="headerlink" title="· 打标签"></a><strong>· 打标签</strong></h3><p>​            有两种类型：<strong>轻量级的（lightweight）和含附注的（annotated）</strong>。轻量级标签就像是个不会变化的分支，实际上它就是个指向    特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件    地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般建议使用含附注型的标签，以便保    留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也行。</p>
<ol>
<li><p>列出现在所有的标签</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用特定的搜索模式列出符合条件的标签，例如只对1.4.2系列的版本感兴趣</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-l</span> <span class="string">&quot;v1.4.2.*&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个含附注类型的标签，需要加<code>-a</code>参数</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">4</span> -m <span class="string">&quot;my version 1.4&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用git show命令查看相应标签的版本信息，并连同显示打标签时的提交对象</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> show v<span class="number">1</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个轻量级标签的话，就直接使用git tag命令即可，连<code>-a</code>,<code>-s</code>以及<code>-m</code>选项都不需要，直接给出标签名字即可</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>将标签推送到远程仓库中</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> push origin v<span class="number">1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>将本地所有的标签全部推送到远程仓库中</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-分支管理"><a href="#·-分支管理" class="headerlink" title="· 分支管理"></a><strong>· 分支管理</strong></h3><ol>
<li><p>创建分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从当前所处的分支切换到其他分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>新建并切换到新建分支上</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>将当前分支与指定分支进行合并</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">merge</span> &lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>显示本地仓库的所有分支</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看各个分支最后一个提交对象的信息</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch -v</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看哪些分支已经合并到当前分支</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git branch <span class="comment">--merged</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看当前哪些分支还没有合并到当前分支</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> branch --<span class="literal">no</span>-merged</span><br></pre></td></tr></table></figure></li>
<li><p>把远程分支合并到当前分支</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">merge</span> &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​        <em>如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；</em><em><strong>(不是特别理解这段话的意思)</strong></em></p>
</li>
<li><p>在远程分支的基础上创建新的本地分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-<span class="built_in">name</span>&gt; &lt;remote-<span class="built_in">name</span>&gt;/&lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从远程分支checkout出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容, 该命令会自动判断应该向远程仓库中的哪个分支推送数据.</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>

<p>在跟踪分支上合并远程分支</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git pull</span></span><br></pre></td></tr></table></figure></li>
<li><p>关于rebase的操作目前还不太理解，先不写在里面啦~</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="本地仓库上的操作"><a href="#本地仓库上的操作" class="headerlink" title="本地仓库上的操作"></a>本地仓库上的操作</h2><ol>
<li><p>查看本地仓库关联的远程仓库</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote</span></span><br></pre></td></tr></table></figure>

<p><em>在克隆完每个远程仓库后，远程仓库默认为 orign，加上<code>-v</code>的参数后，会显示远程仓库的<code>url</code>地址；</em></p>
</li>
<li><p>添加远程仓库，一般会取一个简短的别名</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git remote add example git:<span class="regexp">//gi</span>thub.com<span class="regexp">/example/</span>example.git</span><br></pre></td></tr></table></figure></li>
<li><p>从远程仓库中抓取本地仓库中没有的更新</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">fetch</span> [remote-<span class="type">name</span>]</span><br></pre></td></tr></table></figure>

<p><em>使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用<code>git pull</code>来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；</em></p>
</li>
<li><p>将本地仓库某分支推送到远程仓库上</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git push [remote-<span class="built_in">name</span>] [branch-<span class="built_in">name</span>]</span><br></pre></td></tr></table></figure>

<p>如果想将本地分支推送到远程仓库的不同名分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;local-branch&gt;<span class="symbol">:&lt;remote-branch&gt;</span></span><br><span class="line">如：</span><br><span class="line">git push origin <span class="symbol">serverfix:</span>awesomebranch</span><br></pre></td></tr></table></figure>

<p>如果想删除远程分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push [romote-name] <span class="symbol">:&lt;remote-branch&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。</em></p>
</li>
<li><p>查看远程仓库的详细信息</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">show</span> <span class="built_in">origin</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改某个远程仓库在本地的简称</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">rename</span> [<span class="built_in">old</span>-<span class="type">name</span>] [<span class="built_in">new</span>-<span class="type">name</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>移除远程仓库</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> remote rm<span class="meta"> [remote-name]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h2 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件.gitignore"></a>忽略文件.gitignore</h2><p>​        一般会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"><span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">*<span class="string">.a</span></span><br><span class="line"><span class="comment"># 但 lib.a 除外</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*<span class="string">.txt</span></span><br><span class="line"><span class="comment"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span></span><br><span class="line">doc/**/*<span class="string">.txt</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack基础知识</title>
    <url>/webpack/</url>
    <content><![CDATA[<p>本文主要是总结一下近期看的webpack文档及视频里面的知识点，暂不涉及内部原理和源码分析，持续完善。</p>
<span id="more"></span>



<h1 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a><strong>Webpack是什么</strong></h1><p>​        webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在 webpack 看来, 前端的所有资源文件都会作为模块处理。 它将根据模块的依赖关系进行静态分析，在内部构建依赖图，打包生成对应的静态资源(bundle)。 </p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h1><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>​            打包入口，指示webpack以哪个文件(可以有多个)为入口起点开始打包，然后会找出有哪些模块和库是入口起点(直接或间接)            依赖的。默认值是./src/index.js。 </p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>​             告诉webpack在哪里输出所创建的bundle，以及如何命名这些文件。主要输出文件的默认值为./dist/main.js。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>​                因为webpack本身只理解js文件和JSON文件，所以需要loader去将其他类型的文件转换为webpack可理解的有效模块。</p>
<p>​                两个属性：</p>
<p>​                  1. test: 识别出哪些文件会被转换；</p>
<p>​                2.use: 定义出在进行转换时，应该使用哪个 loader。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>​                执行更加广泛的任务，包括：打包优化，资源管理，注入环境变量等。</p>
<p>​                使用的话，一般只需要require()它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。也可以在一        个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p>​                通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优                化。其默认值为 <code>production</code>。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack开发环境基本配置"><a href="#Webpack开发环境基本配置" class="headerlink" title="Webpack开发环境基本配置"></a><strong>Webpack开发环境基本配置</strong></h1><p>首先需要初始化package.json: npm init</p>
<p>下载安装webpack：(webpack4以上的版本需要全局/本地都安装webpack-cli)</p>
<p>​    <strong>全局安装：</strong> cnpm i webpack webpack-cli -g</p>
<p>​    <strong>本地安装：</strong> cnpm i webpack webpack-cli -D</p>
<p><strong>webpack的配置文件：</strong> webpack.config.js，所有构建工具都是基于 nodejs 平台运行的，模块化默认采用 commonjs。</p>
<p>开发环境主要考虑以下方面：</p>
<ul>
<li>打包样式资源</li>
<li>打包 html 资源</li>
<li>打包图片资源</li>
<li>打包其他资源</li>
<li>devServer</li>
</ul>
<p>下面是一个简单的开发环境webpack.confg.js配置文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>) <span class="comment">// 引用plugin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>, <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/build.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// __dirname是nodejs的变量，代表当前文件的目录绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>), <span class="comment">// 输出路径，所有资源打包都会输出到这个文件夹下</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细的loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 匹配哪些文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上，依次执行(先执行css-loader)</span></span><br><span class="line">          <span class="comment">// style-loader：创建style标签，将js中的样式资源插入进去，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// css-loader：将css文件变成commonjs模块加载到js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// less-loader：将less文件编译成css文件，需要下载less-loader和less</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// url-loader：处理图片资源，问题：默认处理不了html中的img图片</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        <span class="comment">// 需要下载 url-loader file-loader</span></span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 图片大小小于8kb，就会被base64处理，优点：减少请求数量（减轻服务器压力），缺点：图片体积会更大（文件请求速度更慢）</span></span><br><span class="line">          <span class="comment">// base64在客户端本地解码所以会减少服务器压力，如果图片过大还采用base64编码会导致cpu调用率上升，网页加载时变卡</span></span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">// 给图片重命名，[hash:10]：取图片的hash的前10位，[ext]：取文件原来扩展名</span></span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="comment">// 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是conmonjs，解析时会出问题：[object Module]</span></span><br><span class="line">          <span class="comment">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        <span class="comment">// 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span></span><br><span class="line">        loader: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 打包其他资源(除了html/js/css资源以外的资源)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 排除html|js|css|less|jpg|png|gif文件</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class="line">        <span class="comment">// file-loader：处理其他文件</span></span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugin的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin：默认会创建一个空的html文件，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">// 需要有结构的HTML文件可以加一个template</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 复制这个./src/index.html文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// 开发服务器 devServer：用来自动化，不用每次修改后都重新输入webpack打包一遍（自动编译，自动打开浏览器，自动刷新浏览器）</span></span><br><span class="line">  <span class="comment">// 特点：只会在内存中编译打包，不会有任何输出（不会像之前那样在外面看到打包输出的build包，而是在内存中，关闭后会自动删除）</span></span><br><span class="line">  <span class="comment">// 启动devServer指令为：npx webpack-dev-server</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 项目构建后路径</span></span><br><span class="line">    <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="comment">// 启动gzip压缩</span></span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行项目的两个指令：<br>webpack 会将打包结果输出出去（build文件夹）<br>npx webpack-dev-server 只会在内存中编译打包，没有输出</p>
</li>
<li><p>loader 和 plugin 的不同：（plugin 一定要先引入才能使用）</p>
<p> loader：1. 下载 2. 使用（配置 loader）</p>
<p> plugins：1.下载 2. 引入 3. 使用</p>
</li>
</ul>
<h1 id="Webpack生产环境的基本配置"><a href="#Webpack生产环境的基本配置" class="headerlink" title="Webpack生产环境的基本配置"></a><strong>Webpack生产环境的基本配置</strong></h1><p>生产环境的配置需要考虑以下几个方面：</p>
<ul>
<li>提取 css 成单独文件</li>
<li>css 兼容性处理</li>
<li>压缩 css</li>
<li>js 语法检查</li>
<li>js 兼容性处理</li>
<li>js 压缩</li>
<li>html 压缩</li>
</ul>
<p>主要是多了一些兼容性和优化。下面是一个基本的生产环境下的webpack.config.js配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractorPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> OptimiziCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimizi-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义node.js的环境变量，决定使用browserslist的哪个环境</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">&#x27;production&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复用loader的写法</span></span><br><span class="line"><span class="keyword">const</span> commonCssLoader = [</span><br><span class="line">  <span class="comment">// 这个loader取代style-loader。作用：提取js中的css成单独文件然后通过link加载</span></span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  <span class="comment">// css-loader：将css文件整合到js文件中</span></span><br><span class="line">  <span class="comment">// 经过css-loader处理后，样式文件是在js文件中的</span></span><br><span class="line">  <span class="comment">// 问题：1.js文件体积会很大2.需要先加载js再动态创建style标签，样式渲染速度就慢，会出现闪屏现象</span></span><br><span class="line">  <span class="comment">// 解决：用MiniCssExtractPlugin.loader替代style-loader</span></span><br><span class="line">  <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    postcss-loader：css兼容性处理：postcss --&gt; 需要安装：postcss-loader postcss-preset-env</span></span><br><span class="line"><span class="comment">    postcss需要通过package.json中browserslist里面的配置加载指定的css兼容性样式</span></span><br><span class="line"><span class="comment">    在package.json中定义browserslist：</span></span><br><span class="line"><span class="comment">    &quot;browserslist&quot;: &#123;</span></span><br><span class="line"><span class="comment">      // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span></span><br><span class="line"><span class="comment">      &quot;development&quot;: [ // 只需要可以运行即可</span></span><br><span class="line"><span class="comment">        &quot;last 1 chrome version&quot;,</span></span><br><span class="line"><span class="comment">        &quot;last 1 firefox version&quot;,</span></span><br><span class="line"><span class="comment">        &quot;last 1 safari version&quot;</span></span><br><span class="line"><span class="comment">      ],</span></span><br><span class="line"><span class="comment">      // 生产环境。默认是生产环境</span></span><br><span class="line"><span class="comment">      &quot;production&quot;: [ // 需要满足绝大多数浏览器的兼容</span></span><br><span class="line"><span class="comment">        &quot;&gt;0.2%&quot;,</span></span><br><span class="line"><span class="comment">        &quot;not dead&quot;,</span></span><br><span class="line"><span class="comment">        &quot;not op_mini all&quot;</span></span><br><span class="line"><span class="comment">      ]</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">ident</span>: <span class="string">&#x27;postcss&#x27;</span>, <span class="comment">// 基本写法</span></span><br><span class="line">      <span class="attr">plugins</span>: <span class="function">() =&gt;</span> [</span><br><span class="line">        <span class="comment">// postcss的插件</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)(),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [...commonCssLoader],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        正常来讲，一个文件只能被一个loader处理</span></span><br><span class="line"><span class="comment">        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序</span></span><br><span class="line"><span class="comment">        先执行eslint再执行babel（用enforce）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          js的语法检查： 需要下载 eslint-loader eslint</span></span><br><span class="line"><span class="comment">          注意：只检查自己写的源代码，第三方的库是不用检查的</span></span><br><span class="line"><span class="comment">          airbnb(一个流行的js风格) --&gt; 需要下载 eslint-config-airbnb-base eslint-plugin-import</span></span><br><span class="line"><span class="comment">          设置检查规则：</span></span><br><span class="line"><span class="comment">            package.json中eslintConfig中设置</span></span><br><span class="line"><span class="comment">              &quot;eslintConfig&quot;: &#123;</span></span><br><span class="line"><span class="comment">                &quot;extends&quot;: &quot;airbnb-base&quot;， // 继承airbnb的风格规范</span></span><br><span class="line"><span class="comment">                &quot;env&quot;: &#123;</span></span><br><span class="line"><span class="comment">                  &quot;browser&quot;: true // 可以使用浏览器中的全局变量(使用window不会报错)</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 忽略node_modules</span></span><br><span class="line">        enforce: <span class="string">&#x27;pre&#x27;</span>, <span class="comment">// 优先执行</span></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 自动修复</span></span><br><span class="line">          <span class="attr">fix</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        js兼容性处理：需要下载 babel-loader @babel/core</span></span><br><span class="line"><span class="comment">          1. 基本js兼容性处理 --&gt; @babel/preset-env</span></span><br><span class="line"><span class="comment">            问题：只能转换基本语法，如promise高级语法不能转换</span></span><br><span class="line"><span class="comment">          2. 全部js兼容性处理 --&gt; @babel/polyfill</span></span><br><span class="line"><span class="comment">            问题：只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了</span></span><br><span class="line"><span class="comment">          3. 需要做兼容性处理的就做：按需加载  --&gt; core-js</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 第三种方式：按需加载</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 预设：指示babel做怎样的兼容性处理</span></span><br><span class="line">          <span class="attr">presets</span>: [</span><br><span class="line">            <span class="string">&#x27;@babel/preset-env&#x27;</span>, <span class="comment">// 基本预设</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>, <span class="comment">//按需加载</span></span><br><span class="line">              <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;, <span class="comment">// 指定core-js版本</span></span><br><span class="line">              <span class="attr">targets</span>: &#123; <span class="comment">// 指定兼容到什么版本的浏览器</span></span><br><span class="line">                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span>,</span><br><span class="line">                <span class="attr">ie</span>: <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">                <span class="attr">safari</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">                <span class="attr">edge</span>: <span class="string">&#x27;17&#x27;</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 图片处理</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>, <span class="comment">// 关闭url-loader默认使用的es6模块化解析</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// html中的图片处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 处理其他文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(js|css|less|html|jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 对输出的css文件进行重命名</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;css/built.css&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimiziCssAssetsWebpackPlugin(),</span><br><span class="line">    <span class="comment">// HtmlWebpackPlugin：html文件的打包和压缩处理</span></span><br><span class="line">    <span class="comment">// 通过这个插件会自动将单独打包的样式文件通过link标签引入</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="comment">// 压缩html代码</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="comment">// 移除空格</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 移除注释</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 生产环境下会自动压缩js代码</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack-优化配置"><a href="#Webpack-优化配置" class="headerlink" title="Webpack 优化配置"></a>Webpack 优化配置</h1><h2 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h2><h3 id="HMR-模块热替换"><a href="#HMR-模块热替换" class="headerlink" title="HMR(模块热替换)"></a>HMR(模块热替换)</h3><p>开启之后，当我们修改了项目代码，webpack 会监听到文件内容的变化，并且重新进行编译等工作，然后会把新的代码通过 websocket 发送给浏览器。浏览器获取到新的代码之后会重新执行模块代码，并且替换模块的内容。这样当一个模块发生变化，只会重新打包构建这一个模块（而不是打包所有模块） ，极大提升构建速度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 开启HMR功能</span></span><br><span class="line">  <span class="comment">// 当修改了webpack配置，新配置要想生效，必须重启webpack服务</span></span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种文件实现热模块替换的情况：</p>
<ul>
<li><p>样式文件：可以使用HMR功能，因为开发环境下使用的 style-loader 内部默认实现了热模块替换功能</p>
</li>
<li><p>js 文件：默认不能使用HMR功能（修改一个 js 模块所有 js 模块都会刷新）</p>
<p>–&gt; 实现 HMR 需要修改 js 代码（添加支持 HMR 功能的代码）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./print.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 方法会监听 print.js 文件的变化，一旦发生变化，只有这个模块会重新打包构建，其他模块不会。</span></span><br><span class="line">    <span class="comment">// 会执行后面的回调函数</span></span><br><span class="line">    print();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件。</p>
</li>
<li><p>html 文件: 默认不能使用 HMR 功能（html 不用做 HMR 功能，因为只有一个 html 文件，不需要再优化）</p>
<p>使用 HMR 会导致问题：html 文件不能热更新了（不会自动打包构建）</p>
<p>解决：修改 entry 入口，将 html 文件引入（这样 html 修改整体刷新）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: [<span class="string">&#x27;./src/js/index.js&#x27;</span>, <span class="string">&#x27;./src/index.html&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>一种提供<strong>源代码到构建后代码的映射</strong>的技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</p>
<p>参数：<code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;eval-source-map&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可选方案：[生成source-map的位置|给出的错误代码信息]</p>
<ul>
<li>source-map：外部，错误代码准确信息 和 源代码的错误位置</li>
<li>inline-source-map：内联，只生成一个内联 source-map，错误代码准确信息 和 源代码的错误位置</li>
<li>hidden-source-map：外部，错误代码错误原因，但是没有错误位置（为了隐藏源代码），不能追踪源代码错误，只能提示到构建后代码的错误位置</li>
<li>eval-source-map：内联，每一个文件都生成对应的 source-map，都在 eval 中，错误代码准确信息 和 源代码的错误位</li>
<li>nosources-source-map：外部，错误代码准确信息，但是没有任何源代码信息（为了隐藏源代码）</li>
<li>cheap-source-map：外部，错误代码准确信息 和 源代码的错误位置，只能把错误精确到整行，忽略列</li>
<li>cheap-module-source-map：外部，错误代码准确信息 和 源代码的错误位置，module 会加入 loader 的 source-map</li>
</ul>
<p>内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</p>
<p>开发/生产环境可做的选择：</p>
<p><strong>开发环境</strong>：需要考虑速度快，调试更友好</p>
<ul>
<li>速度快( eval &gt; inline &gt; cheap &gt;… )<ol>
<li>eval-cheap-souce-map</li>
<li>eval-source-map</li>
</ol>
</li>
<li>调试更友好<ol>
<li>souce-map</li>
<li>cheap-module-souce-map</li>
<li>cheap-souce-map</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; eval-source-map（完整度高，内联速度快） / eval-cheap-module-souce-map（错误提示忽略列但是包含其他信息，内联速度快）</strong></p>
<p><strong>生产环境</strong>：需要考虑源代码要不要隐藏，调试要不要更友好</p>
<ul>
<li>内联会让代码体积变大，所以在生产环境不用内联</li>
<li>隐藏源代码<ol>
<li>nosources-source-map 全部隐藏</li>
<li>hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; source-map（最完整） / cheap-module-souce-map（错误提示一整行忽略列）</strong></p>
<h2 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h2><h3 id="优化打包构建速度"><a href="#优化打包构建速度" class="headerlink" title="优化打包构建速度"></a>优化打包构建速度</h3><h4 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h4><p>作用：匹配到 loader 后就不再向后进行匹配，优化生产环境的打包构建速度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// js 语法检查</span></span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// 优先执行</span></span><br><span class="line">      enforce: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">fix</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// oneOf 优化生产环境的打包构建速度</span></span><br><span class="line">      <span class="comment">// 以下loader只会匹配一个（匹配到了后就不会再往下匹配了）</span></span><br><span class="line">      <span class="comment">// 注意：不能有两个配置处理同一种类型文件（所以把eslint-loader提取出去放外面）</span></span><br><span class="line">      <span class="attr">oneOf</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [...commonCssLoader]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// js 兼容性处理</span></span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                  <span class="attr">corejs</span>: &#123;<span class="attr">version</span>: <span class="number">3</span>&#125;,</span><br><span class="line">                  <span class="attr">targets</span>: &#123;</span><br><span class="line">                    <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                    <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">            <span class="attr">esModule</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">exclude</span>: <span class="regexp">/\.(js|css|less|html|jpg|png|gif)/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="·-babel缓存"><a href="#·-babel缓存" class="headerlink" title="· babel缓存"></a>· babel缓存</h5><p>作用：类似 HMR，将 babel 处理后的资源缓存起来（哪里的 js 改变就更新哪里，其他 js 还是用之前缓存的资源），让第二次打包构建速度更快。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">          <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">          <span class="attr">targets</span>: &#123;</span><br><span class="line">            <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">            <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 开启babel缓存</span></span><br><span class="line">    <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">    <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h5 id="·-文件资源缓存"><a href="#·-文件资源缓存" class="headerlink" title="· 文件资源缓存"></a>· 文件资源缓存</h5><p>文件名不变，就不会重新请求，而是再次用之前缓存的资源。</p>
<p><strong>1.hash:</strong> 每次 wepack 打包时会生成一个唯一的 hash 值。</p>
<p> 问题：重新打包，所有文件的 hsah 值都改变，会导致所有缓存失效。（可能只改动了一个文件）</p>
<p><strong>2.chunkhash：</strong>根据 chunk 生成的 hash 值。来源于同一个 chunk的 hash 值一样。</p>
<p> 问题：js 和 css 来自同一个chunk，hash 值是一样的（因为 css-loader 会将 css 文件加载到 js 中，所以同属于一个chunk）。</p>
<p><strong>3.contenthash:</strong> 根据文件的内容生成 hash 值。不同文件 hash 值一定不一样(文件内容修改，文件名里的 hash 才会改变)。</p>
<p>修改 css 文件内容，打包后的 css 文件名 hash 值就改变，而 js 文件没有改变 hash 值就不变，这样 css 和 js 缓存就会分开判断要不要重新请求资源 –&gt; 让代码上线运行缓存更好使用。</p>
<h4 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h4><p>某个任务消耗时间较长会卡顿，多进程可以同一时间干多件事，效率更高。</p>
<p>优点是提升打包速度，缺点是每个进程的开启和交流都会有开销（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      thread-loader会对其后面的loader（这里是babel-loader）开启多进程打包。 </span></span><br><span class="line"><span class="comment">      进程启动大概为600ms，进程通信也有开销。(启动的开销比较昂贵，不要滥用)</span></span><br><span class="line"><span class="comment">      只有工作消耗时间比较长，才需要多进程打包</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">workers</span>: <span class="number">2</span> <span class="comment">// 进程2个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">presets</span>: [</span><br><span class="line">          [</span><br><span class="line">            <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">              <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">              <span class="attr">targets</span>: &#123;</span><br><span class="line">                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 开启babel缓存</span></span><br><span class="line">        <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">        <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>作用：让某些库不打包，通过 cdn 引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js 中配置：</span></span><br><span class="line"><span class="attr">externals</span>: &#123;</span><br><span class="line">  <span class="comment">// 拒绝jQuery被打包进来(通过cdn引入，速度会快一些)</span></span><br><span class="line">  <span class="comment">// 忽略的库名 -- npm包名</span></span><br><span class="line">  <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在 index.html 中通过 cdn 引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h4><p>作用：让某些库单独打包，后直接引入到 build 中。可以在 code split 分割出 node_modules 后再用 dll 更细的分割，优化代码运行的性能。</p>
<p><em><strong>webpack.dll.js 配置：(将 jquery 单独打包)</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  node_modules的库会打包到一起，但是很多库的时候打包输出的js文件就太大了</span></span><br><span class="line"><span class="comment">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span></span><br><span class="line"><span class="comment">  当运行webpack时，默认查找webpack.config.js配置文件</span></span><br><span class="line"><span class="comment">  需求：需要运行webpack.dll.js文件</span></span><br><span class="line"><span class="comment">    --&gt; webpack --config webpack.dll.js（运行这个指令表示以这个配置文件打包）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 最终打包生成的[name] --&gt; jquery</span></span><br><span class="line">    <span class="comment">// [&#x27;jquery] --&gt; 要打包的库是jquery</span></span><br><span class="line">    <span class="attr">jquery</span>: [<span class="string">&#x27;jquery&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出出口指定</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>, <span class="comment">// name就是jquery</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll&#x27;</span>), <span class="comment">// 打包到dll目录下</span></span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 打包的库里面向外暴露出去的内容叫什么名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 打包生成一个manifest.json --&gt; 提供jquery的映射关系（告诉webpack：jquery之后不需要再打包和暴露内容的名称）</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 映射库的暴露的内容名称</span></span><br><span class="line">      <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>) <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 配置：(告诉 webpack 不需要再打包 jquery，并将之前打包好的 jquery 跟其他打包好的资源一同输出到 build 目录下)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins中配置：</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 告诉webpack哪些库不参与打包，同时使用时的名称也得变</span></span><br><span class="line">  <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    <span class="attr">manifest</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 将某个文件打包输出到build目录下，并在html中自动引入该资源</span></span><br><span class="line">  <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">filepath</span>: resolve(__dirname, <span class="string">&#x27;dll/jquery.js&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="优化代码运行的性能"><a href="#优化代码运行的性能" class="headerlink" title="优化代码运行的性能"></a>优化代码运行的性能</h3><h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h4><p>作用：去除源代码中的无用代码，减少代码体积。</p>
<p>前提：1. 必须使用 ES6 模块化 2. 开启 production 环境 （这样就自动会把无用代码去掉）</p>
<p>在 package.json 中配置：<code>&quot;sideEffects&quot;: false</code> 表示所有代码都没有副作用（都可以进行 tree shaking），这样会导致的问题：可能会把 css / @babel/polyfill 文件干掉（副作用）。</p>
<p>所以可以配置：<code>&quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</code> 不会对css/less文件tree shaking处理。</p>
<h4 id="code-split（代码分割）"><a href="#code-split（代码分割）" class="headerlink" title="code split（代码分割）"></a>code split（代码分割）</h4><p>作用：将打包输出的一个大的 bundle.js 文件拆分成多个小文件，这样可以并行加载多个文件，比加载一个文件更快。</p>
<p><strong>module,chunk,bundle区分：</strong><a href="https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html">https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html</a></p>
<h5 id="多入口拆分"><a href="#多入口拆分" class="headerlink" title="多入口拆分"></a>多入口拆分</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="comment">// 多入口：有一个入口，最终输出就有一个bundle</span></span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;./src/js/test.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// [name]：取文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash:10].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h5 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>将 node_modules 中的代码单独打包（大小超过30kb）；</li>
<li>自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk(比如两个模块中都引入了jquery会被打包成单独的文件)（大小超过30kb）。</li>
</ul>
<h5 id="import-动态导入语法"><a href="#import-动态导入语法" class="headerlink" title="import 动态导入语法"></a>import 动态导入语法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  通过js代码，让某个文件被单独打包成一个chunk</span></span><br><span class="line"><span class="comment">  import动态导入语法：能将某个文件单独打包(test文件不会和index打包在同一个文件而是单独打包)</span></span><br><span class="line"><span class="comment">  webpackChunkName:指定test单独打包后文件的名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27; */</span><span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; mul, count &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 文件加载成功~</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件加载失败~&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="lazy-loading（懒加载-预加载）"><a href="#lazy-loading（懒加载-预加载）" class="headerlink" title="lazy loading（懒加载/预加载）"></a>lazy loading（懒加载/预加载）</h4><p><strong>1.懒加载：</strong>当文件需要使用时才加载（需要代码分割）。但是如果资源较大，加载时间就会较长，有延迟。</p>
<p><strong>2.正常加载：</strong>可以认为是并行加载（同一时间加载多个文件）没有先后顺序，先加载了不需要的资源就会浪费时间。</p>
<p><strong>3.预加载 prefetch（兼容性很差）：</strong>会在使用之前，提前加载。等其他资源加载完毕，浏览器空闲了，再偷偷加载这个资源。这样在使用时已经加载好了，速度很快。所以在懒加载的基础上加上预加载会更好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将import的内容放在异步回调函数中使用，点击按钮，test.js才会被加载(不会重复加载)</span></span><br><span class="line">  <span class="comment">// webpackPrefetch: true表示开启预加载</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */</span><span class="string">&#x27;./test&#x27;</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./test&#x27;</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="pwa（离线可访问技术）"><a href="#pwa（离线可访问技术）" class="headerlink" title="pwa（离线可访问技术）"></a>pwa（离线可访问技术）</h4><p>使用 serviceworker 和 workbox 技术。优点是离线也能访问，缺点是兼容性差。</p>
<p><em><strong>webpack.config.js 中配置：</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;workbox-webpack-plugin&#x27;</span>); <span class="comment">// 引入插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins中加入：</span></span><br><span class="line"><span class="keyword">new</span> WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 帮助serviceworker快速启动</span></span><br><span class="line"><span class="comment">    2. 删除旧的 serviceworker</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    生成一个 serviceworker 配置文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attr">clientsClaim</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">skipWaiting</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><em><strong>index.js 中还需要写一段代码来激活它的使用：</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. eslint不认识 window、navigator全局变量</span></span><br><span class="line"><span class="comment">    解决：需要修改package.json中eslintConfig配置</span></span><br><span class="line"><span class="comment">    &quot;env&quot;: &#123;</span></span><br><span class="line"><span class="comment">      &quot;browser&quot;: true // 支持浏览器端全局变量</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  2. sw代码必须运行在服务器上</span></span><br><span class="line"><span class="comment">    --&gt; nodejs</span></span><br><span class="line"><span class="comment">    或--&gt;</span></span><br><span class="line"><span class="comment">      npm i serve -g</span></span><br><span class="line"><span class="comment">      serve -s build 启动服务器，将打包输出的build目录下所有资源作为静态资源暴露出去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123; <span class="comment">// 处理兼容性问题</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">&#x27;/service-worker.js&#x27;</span>) <span class="comment">// 注册serviceWorker</span></span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册成功了~&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册失败了~&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>资源构建打包工具</category>
      </categories>
      <tags>
        <tag>打包工具</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
</search>
