<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>节流和防抖</title>
    <url>/debounce&amp;throttle/</url>
    <content><![CDATA[<p>最近在项目中用到了节流，在这里总结一下防抖和节流，以及一些闭包的知识。</p>
<span id="more"></span>

<h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p><strong>定义：</strong>在事件被触发n秒后再执行回调，如果在n秒内又被触发，就重新计时。其实就是某一段时间内只执行一次。</p>
<p>举个例子，现在实现一个功能，在输入框中输入一个字符，先显示waiting ，延迟1秒后在下方输出这个字符，类似于百度输入框。</p>
<p>如果不使用防抖的话，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params">text</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=text.target.value</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    <span class="keyword">let</span> timeout;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        	showInfo(e)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,delay)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=<span class="string">&#x27;waiting&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200404221805681.gif" alt="不使用防抖的结果"></p>
<p><strong>原因就是：</strong>当我们多次输入，就会多次调用回调函数，就会将多个定时器加入宏任务队列，每一个都是1s后执行，那这样就会交叉显示了，看起来很抖，如果每一次都得请求接口的话，就会资源浪费而且耗时。</p>
<p>下面看一下用防抖的结果，思路就是在下一次调用函数的时候，把上一次的定时器关掉。这样其实有两种做法，我们需要维护一个变量用来保存每次开启的定时器，可以采用全局变量保存，或者使用闭包。</p>
<p>看看全局变量的做法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> timeout;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       	showInfo(e)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       &#125;, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,delay)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=<span class="string">&#x27;waiting&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200404223448631.gif" alt="不使用闭包实现防抖"></p>
<p><em>之后会说一下为什么不使用闭包的话，timeout变量必须是全局。</em></p>
<p>再来看看使用闭包的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params">text</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=text.target.value</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    <span class="keyword">let</span> timeout;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	            func.apply(context, args)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        &#125;, wait);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,debounce(showInfo,<span class="number">1000</span>))</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=<span class="string">&#x27;waiting&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>那么为什么不使用闭包的话，必须设置为全局变量呢？</strong></p>
<p>其实javascript里的全局定义的变量，即使程序之后没有用到它，也还是不会被内存回收，是一直存在的，而存在于函数中的局部变量，当函数被调用时，会在内存中开辟空间用来存放函数中定义的局部变量(函数也是)，但是当函数执行完毕后，这些变量都会被回收，也就是说，无论我们对一个函数重复调用多少次，每一次都是创建新的变量，开辟新的空间，之间没有任何联系。</p>
<p>那么有没有办法可以在函数调用完后，将里面的变量保存下来呢？这就得用到闭包了。javascript会在函数调用完成之后回收变量空间的原因，是因为这些变量没有被外界使用或者引用，如果我们可以定义一个外界(全局)的变量，接收到函数里面某个变量的值，即函数内部的变量被引用，那么即使在函数被调用之后，由于外界还存在引用，整个函数里的变量的状态都会被保存。</p>
<p>一般的做法就是在函数内部返回一个函数，然后外界创建一个变量接收，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Outer</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    n ++;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Outer(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>当我们多次调用a的时候，就会实现n的累加，因为每一次调用的n都是第一次调用时候创建的那个，实现了变量的状态保持。</p>
<p><strong>所以这里使用闭包的好处就是：</strong></p>
<ol>
<li>可以避免全局变量污染作用域，就像上面的代码，不使用闭包的话，就得定义全局变量维持状态，会造成污染。污染是什么意思？</li>
</ol>
<p>我理解的大概是：一是会命名冲突；二是我们定义的全局变量都会挂载在window上，变成属性和方法，这样每次项目启动运行的时候就会造成加载方面的问题(太深入的还没研究~)</p>
<ol>
<li>如果一个页面上需要多个防抖函数，那么我们得写很多重复的代码，没有实现函数的封装复用。</li>
</ol>
<p><em><strong>使用场景：</strong></em></p>
<ol>
<li>search搜索联想，用户在输入框中不断输入值，我们只需要在用户最后一次输入后请求接口就好了。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次。</li>
</ol>
<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p><strong>定义：</strong>规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。</p>
<p><strong>我此次的需求就是：</strong>添加一个按钮，用户可以点击查看自己当前的进度，其实就是调后台接口进行判断，然后将结果展示，但是用户可能会频繁点击，我又不太想加禁用……，但是频繁调接口又会有一定延时，体验不太好，所以最终想要用户1min内只能请求一次接口，如果在第一次点击之后的一分钟内多次点击，给用户提示请稍后，不做其他操作。</p>
<p>我一开始的做法是维护一个全局的标志位flag，代码类似下面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> checkState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">const</span> checkParams = &#123;</span><br><span class="line">        merchant_sn,</span><br><span class="line">        dev_code,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 调接口</span></span><br><span class="line">      queryApplyStatus(checkParams).then(<span class="function">(<span class="params">&#123; data &#125;: &#123; data: any &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">          &#125;, <span class="number">1000</span> * <span class="number">60</span>);</span><br><span class="line">          <span class="keyword">const</span> &#123; contract_memo = <span class="string">&#x27;&#x27;</span>, contract_code = <span class="string">&#x27;&#x27;</span>, qrcode = <span class="string">&#x27;&#x27;</span> &#125; = data;</span><br><span class="line">         	<span class="comment">// 然后根据返回结果做一些业务处理</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;请稍后&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>其实这样写也还算能完成功能，但是看了网上相关的代码，觉得可以尝试自己封装一个节流函数，之后再遇到类似问题，直接用就好。下面是我自己封的一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">throttle = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">      <span class="keyword">if</span> (nowTime - lastTime &gt; wait) &#123;</span><br><span class="line">        fn();</span><br><span class="line">        lastTime = nowTime;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        toast(<span class="string">&#x27;请勿频繁点击&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>没有用定时器去做，因为觉得有时候异步任务很多时，定时器不是准确的，所以用了时间戳去判断。网上还有更好的例子，在这里就不提供示例代码啦~</p>
<p>其实这里还有个小问题，当用户刷新的时候，保留的状态还是会被清掉，这样其实还是会出现重复请求的问题，后来的做法是将lastTime存在了SessionStorage里面(LocalStorage也是可以的，看业务场景)。</p>
<p><em><strong>使用场景：</strong></em></p>
<ol>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)；</li>
<li>监听滚动事件，比如是否滑到底部加载更多。</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS小技能</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用指令</title>
    <url>/git/</url>
    <content><![CDATA[<p>主要是记录git工作流程和归纳一下日常常用的git操作命令，防止遗忘。</p>
<span id="more"></span>

<p>git主要涉及到以下四个关键点：</p>
<p>&emsp;&emsp;<strong>工作区</strong>：本地电脑存放项目文件的地方；</p>
<p>&emsp;&emsp;<strong>暂存区（Index/Stage）</strong>：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版                                                    本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文                                                    件的地方，通常使用add命令将工作区的文件添加到暂存区里；</p>
<p>&emsp;&emsp;<strong>本地仓库：</strong>.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中                          的文件添加到本地仓库中；</p>
<p>&emsp;&emsp;<strong>远程仓库：</strong>不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将                          远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcc0e7e711dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="git几个核心区域间的关系"></p>
<p>所以其实git命令可以划分为以下：</p>
<ol>
<li><strong>git管理配置的命令；</strong></li>
<li><strong>工作区与暂存区的交互；</strong></li>
<li><strong>暂存区与本地仓库（分支）上的交互；</strong></li>
<li><strong>本地仓库与远程仓库的交互。</strong></li>
</ol>
<p>&emsp;</p>
<h2 id="git配置相关"><a href="#git配置相关" class="headerlink" title="git配置相关"></a>git配置相关</h2><ol>
<li><strong>配置用户名和邮箱：</strong></li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;your name&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;youremail@github.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h2 id="工作区上的操作命令"><a href="#工作区上的操作命令" class="headerlink" title="工作区上的操作命令"></a>工作区上的操作命令</h2><h3 id="·-新建仓库"><a href="#·-新建仓库" class="headerlink" title="· 新建仓库"></a><strong>· 新建仓库</strong></h3><ol>
<li><p>将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure></li>
<li><p>从远程git仓库复制项目，克隆项目时如果想定义新的项目名，可以在指令后面指定：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone git:<span class="regexp">//gi</span>thub.com<span class="regexp">/wasd/</span>example.git mygit</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-提交"><a href="#·-提交" class="headerlink" title="· 提交"></a><strong>· 提交</strong></h3><ol>
<li><p>提交工作区所有文件到暂存区</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> .</span><br></pre></td></tr></table></figure></li>
<li><p>提交指定文件到暂存区</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">add</span> <span class="symbol">&lt;file1&gt;</span> <span class="symbol">&lt;file2&gt;</span> ...</span><br></pre></td></tr></table></figure></li>
<li><p>提交工作区中某个文件夹中所有文件到暂存区</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> [dir]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-撤销"><a href="#·-撤销" class="headerlink" title="· 撤销"></a><strong>· 撤销</strong></h3><ol>
<li><p>删除工作区文件，并从暂存区删除对应文件的记录</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> rm &lt;file<span class="number">1</span>&gt; &lt;file<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从暂存区删除文件，但是工作区依然还有该文件</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">rm</span> --cached &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>取消暂存区已经暂存的文件</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">git <span class="meta">reset</span> HEAD &lt;<span class="meta">file</span>&gt;...</span><br></pre></td></tr></table></figure></li>
<li><p>撤销上一次对文件的操作</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">--&lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <em>要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理</em></p>
</li>
</ol>
<h3 id="·-更新文件"><a href="#·-更新文件" class="headerlink" title="· 更新文件"></a><strong>· 更新文件</strong></h3><ol>
<li><p>重命名文件，并将已改名文件提交到暂存区</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git mv [<span class="built_in">file</span>-original] [<span class="built_in">file</span>-renamed]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-查询状态"><a href="#·-查询状态" class="headerlink" title="· 查询状态"></a><strong>· 查询状态</strong></h3><ol>
<li><p>查询当前工作区所有文件的状态</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容(也可以指定文件)</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git diff &lt;<span class="built_in">file</span>-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h2 id="暂存区上的操作命令"><a href="#暂存区上的操作命令" class="headerlink" title="暂存区上的操作命令"></a>暂存区上的操作命令</h2><h3 id="·-提交文件到版本库"><a href="#·-提交文件到版本库" class="headerlink" title="· 提交文件到版本库"></a><strong>· 提交文件到版本库</strong></h3><ol>
<li><p>将暂存区中的文件提交到本地仓库，打上新版本</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&quot;commit_info&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">&quot;commit_info&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-查看信息"><a href="#·-查看信息" class="headerlink" title="· 查看信息"></a><strong>· 查看信息</strong></h3><ol>
<li><p>比较暂存区与上一版本的差异</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git diff &lt;<span class="built_in">file</span>-<span class="built_in">name</span>&gt; <span class="comment">--cached</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看提交历史，参数-p展开每次提交的历史差异，用-2显示最近的两次更新</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p -<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-打标签"><a href="#·-打标签" class="headerlink" title="· 打标签"></a><strong>· 打标签</strong></h3><p>​            有两种类型：<strong>轻量级的（lightweight）和含附注的（annotated）</strong>。轻量级标签就像是个不会变化的分支，实际上它就是个指向    特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件    地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般建议使用含附注型的标签，以便保    留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也行。</p>
<ol>
<li><p>列出现在所有的标签</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用特定的搜索模式列出符合条件的标签，例如只对1.4.2系列的版本感兴趣</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-l</span> <span class="string">&quot;v1.4.2.*&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个含附注类型的标签，需要加<code>-a</code>参数</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">4</span> -m <span class="string">&quot;my version 1.4&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用git show命令查看相应标签的版本信息，并连同显示打标签时的提交对象</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> show v<span class="number">1</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个轻量级标签的话，就直接使用git tag命令即可，连<code>-a</code>,<code>-s</code>以及<code>-m</code>选项都不需要，直接给出标签名字即可</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>将标签推送到远程仓库中</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> push origin v<span class="number">1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>将本地所有的标签全部推送到远程仓库中</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-分支管理"><a href="#·-分支管理" class="headerlink" title="· 分支管理"></a><strong>· 分支管理</strong></h3><ol>
<li><p>创建分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从当前所处的分支切换到其他分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>新建并切换到新建分支上</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>将当前分支与指定分支进行合并</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">merge</span> &lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>显示本地仓库的所有分支</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看各个分支最后一个提交对象的信息</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch -v</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看哪些分支已经合并到当前分支</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git branch <span class="comment">--merged</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看当前哪些分支还没有合并到当前分支</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> branch --<span class="literal">no</span>-merged</span><br></pre></td></tr></table></figure></li>
<li><p>把远程分支合并到当前分支</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">merge</span> &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​        <em>如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；</em><em><strong>(不是特别理解这段话的意思)</strong></em></p>
</li>
<li><p>在远程分支的基础上创建新的本地分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-<span class="built_in">name</span>&gt; &lt;remote-<span class="built_in">name</span>&gt;/&lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从远程分支checkout出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容, 该命令会自动判断应该向远程仓库中的哪个分支推送数据.</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>

<p>在跟踪分支上合并远程分支</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git pull</span></span><br></pre></td></tr></table></figure></li>
<li><p>关于rebase的操作目前还不太理解，先不写在里面啦~</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="本地仓库上的操作"><a href="#本地仓库上的操作" class="headerlink" title="本地仓库上的操作"></a>本地仓库上的操作</h2><ol>
<li><p>查看本地仓库关联的远程仓库</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote</span></span><br></pre></td></tr></table></figure>

<p><em>在克隆完每个远程仓库后，远程仓库默认为 orign，加上<code>-v</code>的参数后，会显示远程仓库的<code>url</code>地址；</em></p>
</li>
<li><p>添加远程仓库，一般会取一个简短的别名</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git remote add example git:<span class="regexp">//gi</span>thub.com<span class="regexp">/example/</span>example.git</span><br></pre></td></tr></table></figure></li>
<li><p>从远程仓库中抓取本地仓库中没有的更新</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">fetch</span> [remote-<span class="type">name</span>]</span><br></pre></td></tr></table></figure>

<p><em>使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用<code>git pull</code>来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；</em></p>
</li>
<li><p>将本地仓库某分支推送到远程仓库上</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git push [remote-<span class="built_in">name</span>] [branch-<span class="built_in">name</span>]</span><br></pre></td></tr></table></figure>

<p>如果想将本地分支推送到远程仓库的不同名分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;local-branch&gt;<span class="symbol">:&lt;remote-branch&gt;</span></span><br><span class="line">如：</span><br><span class="line">git push origin <span class="symbol">serverfix:</span>awesomebranch</span><br></pre></td></tr></table></figure>

<p>如果想删除远程分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push [romote-name] <span class="symbol">:&lt;remote-branch&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。</em></p>
</li>
<li><p>查看远程仓库的详细信息</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">show</span> <span class="built_in">origin</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改某个远程仓库在本地的简称</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">rename</span> [<span class="built_in">old</span>-<span class="type">name</span>] [<span class="built_in">new</span>-<span class="type">name</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>移除远程仓库</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> remote rm<span class="meta"> [remote-name]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h2 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件.gitignore"></a>忽略文件.gitignore</h2><p>​        一般会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"><span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">*<span class="string">.a</span></span><br><span class="line"><span class="comment"># 但 lib.a 除外</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*<span class="string">.txt</span></span><br><span class="line"><span class="comment"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span></span><br><span class="line">doc/**/*<span class="string">.txt</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks</title>
    <url>/reactHooks/</url>
    <content><![CDATA[<p>主要记录一下JS中一些基本但是不太容易理解的概念知识。</p>
<span id="more"></span>

<h3 id="·-调用栈与执行上下文"><a href="#·-调用栈与执行上下文" class="headerlink" title="· 调用栈与执行上下文"></a>· 调用栈与执行上下文</h3><p>当一段JS代码被执行，JS引擎先会进行编译，并且创建执行上下文。有以下三种情况可以被算作是“一段代码”。</p>
<ol>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure>

<p>引擎首先会创建全局执行上下文，包含声明的变量和函数。</p>
<img src="https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png" alt="组件层级示例" style="zoom:50%;" />

<p>之后当执行到add()时，JS判断出是函数调用，会：</p>
<ol>
<li>首先，从全局执行上下文中，取出 add 函数代码。</li>
<li>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li>
<li>最后，执行代码，输出结果。</li>
</ol>
<p><strong>执行上下文中包括哪些？</strong></p>
<ol>
<li><strong>变量环境：</strong></li>
</ol>
<p>首先简单说明一下变量提升的概念。</p>
<p>当我们声明了一个变量或者函数时，我们可以把他看做是声明+赋值两部分组成；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;1111&#x27;</span></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">var</span> myname；<span class="comment">// 声明</span></span><br><span class="line">myname = <span class="string">&#x27;1111&#x27;</span>  <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量 bar，再把function()&#123;console.log(&#x27;bar&#x27;)&#125;赋值给 bar。</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p>
<p>变量提升是在编译阶段被JS引擎放入内存。具体如下图：</p>
<img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png" alt="组件层级示例" style="zoom: 67%;" />



<p>如上图，输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。而通过var声明的变量和函数会被放到变量环境中。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</p>
</li>
<li><p> 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。即函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</p>
</li>
</ol>
<ol start="2">
<li><strong>词法环境：</strong></li>
</ol>
<p>ES6引入let,const使得JS也拥有了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在执行到代码块里面时，函数上下文如下图：</p>
<img src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png" alt="组件层级示例" style="zoom:50%;" />

<p>其实在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>下面是变量查找的过程：</p>
<img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" alt="组件层级示例" style="zoom: 50%;" />



<ol start="3">
<li><strong>outer</strong></li>
</ol>
<p>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，称为outer。在查找变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。以此类推，称为作用域链。</p>
<p>而JS执行过程中，其作用域链是由词法作用域决定的。词法作用域就是指<strong>作用域是由代码中函数声明的位置</strong>来决定的，所以词法作用域是静态的作用域。也就是说，<strong>词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p>
<p>通过作用域链可以更深刻的来理解闭包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot;极客时间&quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot;极客邦&quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>当执行到foo函数内部的return innerBar这行代码时，调用栈情况如下：</p>
<img src="https://static001.geekbang.org/resource/image/d5/ef/d5587b76427a56c5f0b0571e4264b7ef.png" alt="组件层级示例" style="zoom:50%;" />

<p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/ee/3f/ee7c1ca481875ad4bdeb4383bd1f883f.png" alt="组件层级示例" style="zoom:50%;" />



<p><strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</strong></p>
<p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的myName = “极客邦”这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：</p>
<img src="https://static001.geekbang.org/resource/image/50/46/50e4ba60fc7e420e83b35b95e379b246.png" alt="组件层级示例" style="zoom:50%;" />



<ol start="4">
<li><strong>this</strong></li>
</ol>
<p>this和执行上下文是绑定的，每个执行上下文中都有一个 this。执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p>
<p><strong>全局执行上下文的this:</strong></p>
<p>全局执行上下文中的 this 指向 window 对象。</p>
<p><strong>函数执行上下文的this:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。</p>
<p>下面是三种来设置函数执行上下文的this值。</p>
<ol>
<li><strong>通过call,apply,bind方法设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">  <span class="attr">test1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar) </span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">//kkk</span></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>通过对象调用方式设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis() <span class="comment">//lol</span></span><br></pre></td></tr></table></figure>

<p>即： <strong>使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。</strong></p>
<p>也可以认为是JS引擎在执行myObject.showThis()时，将其转化为了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObj.showThis.call(myObj)</span><br></pre></td></tr></table></figure>

<p>但是如果我们把一个对象的方法赋值给一个全局对象，然后再调用该对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window, 因为此时相当于在全局环境调用一个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj.showThis</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>通过构造函数方式设置this</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;lol&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> CreateObj()</span><br></pre></td></tr></table></figure>

<p>当执行new Createobj()时，JS引擎做了以下几件事：</p>
<ol>
<li>首先创建了一个空对象 tempObj；</li>
<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li>
<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>
<li>最后返回 tempObj 对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>



<p><strong>this的缺陷</strong></p>
<ol>
<li><strong>嵌套函数中的 this 不会从外层函数中继承</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>执行这段代码后，函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</p>
<p>可以通过一个小技巧来解决这个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      self.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name) <span class="comment">//zzz</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<strong>箭头函数</strong>来解决该问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p>
<ol start="2">
<li><strong>普通函数中的 this 默认指向全局对象 window</strong></li>
</ol>
<p>这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。</p>
<p>可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。</p>
<h4 id="·-总结"><a href="#·-总结" class="headerlink" title="· 总结"></a>· 总结</h4><p>本文主要梳理了一下函数调用栈和执行上下文，以及上下文中包含的四块内容的相关知识点，此为JS的基础知识，需要深刻理解。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack基础知识</title>
    <url>/webpack/</url>
    <content><![CDATA[<p>本文主要是总结一下近期看的webpack文档及视频里面的知识点，暂不涉及内部原理和源码分析，持续完善。</p>
<span id="more"></span>



<h1 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a><strong>Webpack是什么</strong></h1><p>​        webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在 webpack 看来, 前端的所有资源文件都会作为模块处理。 它将根据模块的依赖关系进行静态分析，在内部构建依赖图，打包生成对应的静态资源(bundle)。 </p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h1><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>​            打包入口，指示webpack以哪个文件(可以有多个)为入口起点开始打包，然后会找出有哪些模块和库是入口起点(直接或间接)            依赖的。默认值是./src/index.js。 </p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>​             告诉webpack在哪里输出所创建的bundle，以及如何命名这些文件。主要输出文件的默认值为./dist/main.js。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>​                因为webpack本身只理解js文件和JSON文件，所以需要loader去将其他类型的文件转换为webpack可理解的有效模块。</p>
<p>​                两个属性：</p>
<p>​                  1. test: 识别出哪些文件会被转换；</p>
<p>​                2.use: 定义出在进行转换时，应该使用哪个 loader。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>​                执行更加广泛的任务，包括：打包优化，资源管理，注入环境变量等。</p>
<p>​                使用的话，一般只需要require()它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。也可以在一        个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p>​                通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优                化。其默认值为 <code>production</code>。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack开发环境基本配置"><a href="#Webpack开发环境基本配置" class="headerlink" title="Webpack开发环境基本配置"></a><strong>Webpack开发环境基本配置</strong></h1><p>首先需要初始化package.json: npm init</p>
<p>下载安装webpack：(webpack4以上的版本需要全局/本地都安装webpack-cli)</p>
<p>​    <strong>全局安装：</strong> cnpm i webpack webpack-cli -g</p>
<p>​    <strong>本地安装：</strong> cnpm i webpack webpack-cli -D</p>
<p><strong>webpack的配置文件：</strong> webpack.config.js，所有构建工具都是基于 nodejs 平台运行的，模块化默认采用 commonjs。</p>
<p>开发环境主要考虑以下方面：</p>
<ul>
<li>打包样式资源</li>
<li>打包 html 资源</li>
<li>打包图片资源</li>
<li>打包其他资源</li>
<li>devServer</li>
</ul>
<p>下面是一个简单的开发环境webpack.confg.js配置文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>) <span class="comment">// 引用plugin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>, <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/build.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// __dirname是nodejs的变量，代表当前文件的目录绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>), <span class="comment">// 输出路径，所有资源打包都会输出到这个文件夹下</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细的loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 匹配哪些文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上，依次执行(先执行css-loader)</span></span><br><span class="line">          <span class="comment">// style-loader：创建style标签，将js中的样式资源插入进去，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// css-loader：将css文件变成commonjs模块加载到js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// less-loader：将less文件编译成css文件，需要下载less-loader和less</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// url-loader：处理图片资源，问题：默认处理不了html中的img图片</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        <span class="comment">// 需要下载 url-loader file-loader</span></span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 图片大小小于8kb，就会被base64处理，优点：减少请求数量（减轻服务器压力），缺点：图片体积会更大（文件请求速度更慢）</span></span><br><span class="line">          <span class="comment">// base64在客户端本地解码所以会减少服务器压力，如果图片过大还采用base64编码会导致cpu调用率上升，网页加载时变卡</span></span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">// 给图片重命名，[hash:10]：取图片的hash的前10位，[ext]：取文件原来扩展名</span></span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="comment">// 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是conmonjs，解析时会出问题：[object Module]</span></span><br><span class="line">          <span class="comment">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        <span class="comment">// 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span></span><br><span class="line">        loader: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 打包其他资源(除了html/js/css资源以外的资源)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 排除html|js|css|less|jpg|png|gif文件</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class="line">        <span class="comment">// file-loader：处理其他文件</span></span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugin的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin：默认会创建一个空的html文件，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">// 需要有结构的HTML文件可以加一个template</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 复制这个./src/index.html文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// 开发服务器 devServer：用来自动化，不用每次修改后都重新输入webpack打包一遍（自动编译，自动打开浏览器，自动刷新浏览器）</span></span><br><span class="line">  <span class="comment">// 特点：只会在内存中编译打包，不会有任何输出（不会像之前那样在外面看到打包输出的build包，而是在内存中，关闭后会自动删除）</span></span><br><span class="line">  <span class="comment">// 启动devServer指令为：npx webpack-dev-server</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 项目构建后路径</span></span><br><span class="line">    <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="comment">// 启动gzip压缩</span></span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行项目的两个指令：<br>webpack 会将打包结果输出出去（build文件夹）<br>npx webpack-dev-server 只会在内存中编译打包，没有输出</p>
</li>
<li><p>loader 和 plugin 的不同：（plugin 一定要先引入才能使用）</p>
<p> loader：1. 下载 2. 使用（配置 loader）</p>
<p> plugins：1.下载 2. 引入 3. 使用</p>
</li>
</ul>
<h1 id="Webpack生产环境的基本配置"><a href="#Webpack生产环境的基本配置" class="headerlink" title="Webpack生产环境的基本配置"></a><strong>Webpack生产环境的基本配置</strong></h1><p>生产环境的配置需要考虑以下几个方面：</p>
<ul>
<li>提取 css 成单独文件</li>
<li>css 兼容性处理</li>
<li>压缩 css</li>
<li>js 语法检查</li>
<li>js 兼容性处理</li>
<li>js 压缩</li>
<li>html 压缩</li>
</ul>
<p>主要是多了一些兼容性和优化。下面是一个基本的生产环境下的webpack.config.js配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractorPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> OptimiziCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimizi-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义node.js的环境变量，决定使用browserslist的哪个环境</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">&#x27;production&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复用loader的写法</span></span><br><span class="line"><span class="keyword">const</span> commonCssLoader = [</span><br><span class="line">  <span class="comment">// 这个loader取代style-loader。作用：提取js中的css成单独文件然后通过link加载</span></span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  <span class="comment">// css-loader：将css文件整合到js文件中</span></span><br><span class="line">  <span class="comment">// 经过css-loader处理后，样式文件是在js文件中的</span></span><br><span class="line">  <span class="comment">// 问题：1.js文件体积会很大2.需要先加载js再动态创建style标签，样式渲染速度就慢，会出现闪屏现象</span></span><br><span class="line">  <span class="comment">// 解决：用MiniCssExtractPlugin.loader替代style-loader</span></span><br><span class="line">  <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    postcss-loader：css兼容性处理：postcss --&gt; 需要安装：postcss-loader postcss-preset-env</span></span><br><span class="line"><span class="comment">    postcss需要通过package.json中browserslist里面的配置加载指定的css兼容性样式</span></span><br><span class="line"><span class="comment">    在package.json中定义browserslist：</span></span><br><span class="line"><span class="comment">    &quot;browserslist&quot;: &#123;</span></span><br><span class="line"><span class="comment">      // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span></span><br><span class="line"><span class="comment">      &quot;development&quot;: [ // 只需要可以运行即可</span></span><br><span class="line"><span class="comment">        &quot;last 1 chrome version&quot;,</span></span><br><span class="line"><span class="comment">        &quot;last 1 firefox version&quot;,</span></span><br><span class="line"><span class="comment">        &quot;last 1 safari version&quot;</span></span><br><span class="line"><span class="comment">      ],</span></span><br><span class="line"><span class="comment">      // 生产环境。默认是生产环境</span></span><br><span class="line"><span class="comment">      &quot;production&quot;: [ // 需要满足绝大多数浏览器的兼容</span></span><br><span class="line"><span class="comment">        &quot;&gt;0.2%&quot;,</span></span><br><span class="line"><span class="comment">        &quot;not dead&quot;,</span></span><br><span class="line"><span class="comment">        &quot;not op_mini all&quot;</span></span><br><span class="line"><span class="comment">      ]</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">ident</span>: <span class="string">&#x27;postcss&#x27;</span>, <span class="comment">// 基本写法</span></span><br><span class="line">      <span class="attr">plugins</span>: <span class="function">() =&gt;</span> [</span><br><span class="line">        <span class="comment">// postcss的插件</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)(),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [...commonCssLoader],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        正常来讲，一个文件只能被一个loader处理</span></span><br><span class="line"><span class="comment">        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序</span></span><br><span class="line"><span class="comment">        先执行eslint再执行babel（用enforce）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          js的语法检查： 需要下载 eslint-loader eslint</span></span><br><span class="line"><span class="comment">          注意：只检查自己写的源代码，第三方的库是不用检查的</span></span><br><span class="line"><span class="comment">          airbnb(一个流行的js风格) --&gt; 需要下载 eslint-config-airbnb-base eslint-plugin-import</span></span><br><span class="line"><span class="comment">          设置检查规则：</span></span><br><span class="line"><span class="comment">            package.json中eslintConfig中设置</span></span><br><span class="line"><span class="comment">              &quot;eslintConfig&quot;: &#123;</span></span><br><span class="line"><span class="comment">                &quot;extends&quot;: &quot;airbnb-base&quot;， // 继承airbnb的风格规范</span></span><br><span class="line"><span class="comment">                &quot;env&quot;: &#123;</span></span><br><span class="line"><span class="comment">                  &quot;browser&quot;: true // 可以使用浏览器中的全局变量(使用window不会报错)</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 忽略node_modules</span></span><br><span class="line">        enforce: <span class="string">&#x27;pre&#x27;</span>, <span class="comment">// 优先执行</span></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 自动修复</span></span><br><span class="line">          <span class="attr">fix</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        js兼容性处理：需要下载 babel-loader @babel/core</span></span><br><span class="line"><span class="comment">          1. 基本js兼容性处理 --&gt; @babel/preset-env</span></span><br><span class="line"><span class="comment">            问题：只能转换基本语法，如promise高级语法不能转换</span></span><br><span class="line"><span class="comment">          2. 全部js兼容性处理 --&gt; @babel/polyfill</span></span><br><span class="line"><span class="comment">            问题：只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了</span></span><br><span class="line"><span class="comment">          3. 需要做兼容性处理的就做：按需加载  --&gt; core-js</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 第三种方式：按需加载</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 预设：指示babel做怎样的兼容性处理</span></span><br><span class="line">          <span class="attr">presets</span>: [</span><br><span class="line">            <span class="string">&#x27;@babel/preset-env&#x27;</span>, <span class="comment">// 基本预设</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>, <span class="comment">//按需加载</span></span><br><span class="line">              <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;, <span class="comment">// 指定core-js版本</span></span><br><span class="line">              <span class="attr">targets</span>: &#123; <span class="comment">// 指定兼容到什么版本的浏览器</span></span><br><span class="line">                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span>,</span><br><span class="line">                <span class="attr">ie</span>: <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">                <span class="attr">safari</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">                <span class="attr">edge</span>: <span class="string">&#x27;17&#x27;</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 图片处理</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>, <span class="comment">// 关闭url-loader默认使用的es6模块化解析</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// html中的图片处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 处理其他文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(js|css|less|html|jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 对输出的css文件进行重命名</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;css/built.css&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimiziCssAssetsWebpackPlugin(),</span><br><span class="line">    <span class="comment">// HtmlWebpackPlugin：html文件的打包和压缩处理</span></span><br><span class="line">    <span class="comment">// 通过这个插件会自动将单独打包的样式文件通过link标签引入</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="comment">// 压缩html代码</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="comment">// 移除空格</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 移除注释</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 生产环境下会自动压缩js代码</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack-优化配置"><a href="#Webpack-优化配置" class="headerlink" title="Webpack 优化配置"></a>Webpack 优化配置</h1><h2 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h2><h3 id="HMR-模块热替换"><a href="#HMR-模块热替换" class="headerlink" title="HMR(模块热替换)"></a>HMR(模块热替换)</h3><p>开启之后，当我们修改了项目代码，webpack 会监听到文件内容的变化，并且重新进行编译等工作，然后会把新的代码通过 websocket 发送给浏览器。浏览器获取到新的代码之后会重新执行模块代码，并且替换模块的内容。这样当一个模块发生变化，只会重新打包构建这一个模块（而不是打包所有模块） ，极大提升构建速度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 开启HMR功能</span></span><br><span class="line">  <span class="comment">// 当修改了webpack配置，新配置要想生效，必须重启webpack服务</span></span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种文件实现热模块替换的情况：</p>
<ul>
<li><p>样式文件：可以使用HMR功能，因为开发环境下使用的 style-loader 内部默认实现了热模块替换功能</p>
</li>
<li><p>js 文件：默认不能使用HMR功能（修改一个 js 模块所有 js 模块都会刷新）</p>
<p>–&gt; 实现 HMR 需要修改 js 代码（添加支持 HMR 功能的代码）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./print.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 方法会监听 print.js 文件的变化，一旦发生变化，只有这个模块会重新打包构建，其他模块不会。</span></span><br><span class="line">    <span class="comment">// 会执行后面的回调函数</span></span><br><span class="line">    print();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件。</p>
</li>
<li><p>html 文件: 默认不能使用 HMR 功能（html 不用做 HMR 功能，因为只有一个 html 文件，不需要再优化）</p>
<p>使用 HMR 会导致问题：html 文件不能热更新了（不会自动打包构建）</p>
<p>解决：修改 entry 入口，将 html 文件引入（这样 html 修改整体刷新）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: [<span class="string">&#x27;./src/js/index.js&#x27;</span>, <span class="string">&#x27;./src/index.html&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>一种提供<strong>源代码到构建后代码的映射</strong>的技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</p>
<p>参数：<code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;eval-source-map&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可选方案：[生成source-map的位置|给出的错误代码信息]</p>
<ul>
<li>source-map：外部，错误代码准确信息 和 源代码的错误位置</li>
<li>inline-source-map：内联，只生成一个内联 source-map，错误代码准确信息 和 源代码的错误位置</li>
<li>hidden-source-map：外部，错误代码错误原因，但是没有错误位置（为了隐藏源代码），不能追踪源代码错误，只能提示到构建后代码的错误位置</li>
<li>eval-source-map：内联，每一个文件都生成对应的 source-map，都在 eval 中，错误代码准确信息 和 源代码的错误位</li>
<li>nosources-source-map：外部，错误代码准确信息，但是没有任何源代码信息（为了隐藏源代码）</li>
<li>cheap-source-map：外部，错误代码准确信息 和 源代码的错误位置，只能把错误精确到整行，忽略列</li>
<li>cheap-module-source-map：外部，错误代码准确信息 和 源代码的错误位置，module 会加入 loader 的 source-map</li>
</ul>
<p>内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</p>
<p>开发/生产环境可做的选择：</p>
<p><strong>开发环境</strong>：需要考虑速度快，调试更友好</p>
<ul>
<li>速度快( eval &gt; inline &gt; cheap &gt;… )<ol>
<li>eval-cheap-souce-map</li>
<li>eval-source-map</li>
</ol>
</li>
<li>调试更友好<ol>
<li>souce-map</li>
<li>cheap-module-souce-map</li>
<li>cheap-souce-map</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; eval-source-map（完整度高，内联速度快） / eval-cheap-module-souce-map（错误提示忽略列但是包含其他信息，内联速度快）</strong></p>
<p><strong>生产环境</strong>：需要考虑源代码要不要隐藏，调试要不要更友好</p>
<ul>
<li>内联会让代码体积变大，所以在生产环境不用内联</li>
<li>隐藏源代码<ol>
<li>nosources-source-map 全部隐藏</li>
<li>hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; source-map（最完整） / cheap-module-souce-map（错误提示一整行忽略列）</strong></p>
<h2 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h2><h3 id="优化打包构建速度"><a href="#优化打包构建速度" class="headerlink" title="优化打包构建速度"></a>优化打包构建速度</h3><h4 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h4><p>作用：匹配到 loader 后就不再向后进行匹配，优化生产环境的打包构建速度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// js 语法检查</span></span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// 优先执行</span></span><br><span class="line">      enforce: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">fix</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// oneOf 优化生产环境的打包构建速度</span></span><br><span class="line">      <span class="comment">// 以下loader只会匹配一个（匹配到了后就不会再往下匹配了）</span></span><br><span class="line">      <span class="comment">// 注意：不能有两个配置处理同一种类型文件（所以把eslint-loader提取出去放外面）</span></span><br><span class="line">      <span class="attr">oneOf</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [...commonCssLoader]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// js 兼容性处理</span></span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                  <span class="attr">corejs</span>: &#123;<span class="attr">version</span>: <span class="number">3</span>&#125;,</span><br><span class="line">                  <span class="attr">targets</span>: &#123;</span><br><span class="line">                    <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                    <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">            <span class="attr">esModule</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">exclude</span>: <span class="regexp">/\.(js|css|less|html|jpg|png|gif)/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="·-babel缓存"><a href="#·-babel缓存" class="headerlink" title="· babel缓存"></a>· babel缓存</h5><p>作用：类似 HMR，将 babel 处理后的资源缓存起来（哪里的 js 改变就更新哪里，其他 js 还是用之前缓存的资源），让第二次打包构建速度更快。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">          <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">          <span class="attr">targets</span>: &#123;</span><br><span class="line">            <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">            <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 开启babel缓存</span></span><br><span class="line">    <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">    <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h5 id="·-文件资源缓存"><a href="#·-文件资源缓存" class="headerlink" title="· 文件资源缓存"></a>· 文件资源缓存</h5><p>文件名不变，就不会重新请求，而是再次用之前缓存的资源。</p>
<p><strong>1.hash:</strong> 每次 wepack 打包时会生成一个唯一的 hash 值。</p>
<p> 问题：重新打包，所有文件的 hsah 值都改变，会导致所有缓存失效。（可能只改动了一个文件）</p>
<p><strong>2.chunkhash：</strong>根据 chunk 生成的 hash 值。来源于同一个 chunk的 hash 值一样。</p>
<p> 问题：js 和 css 来自同一个chunk，hash 值是一样的（因为 css-loader 会将 css 文件加载到 js 中，所以同属于一个chunk）。</p>
<p><strong>3.contenthash:</strong> 根据文件的内容生成 hash 值。不同文件 hash 值一定不一样(文件内容修改，文件名里的 hash 才会改变)。</p>
<p>修改 css 文件内容，打包后的 css 文件名 hash 值就改变，而 js 文件没有改变 hash 值就不变，这样 css 和 js 缓存就会分开判断要不要重新请求资源 –&gt; 让代码上线运行缓存更好使用。</p>
<h4 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h4><p>某个任务消耗时间较长会卡顿，多进程可以同一时间干多件事，效率更高。</p>
<p>优点是提升打包速度，缺点是每个进程的开启和交流都会有开销（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      thread-loader会对其后面的loader（这里是babel-loader）开启多进程打包。 </span></span><br><span class="line"><span class="comment">      进程启动大概为600ms，进程通信也有开销。(启动的开销比较昂贵，不要滥用)</span></span><br><span class="line"><span class="comment">      只有工作消耗时间比较长，才需要多进程打包</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">workers</span>: <span class="number">2</span> <span class="comment">// 进程2个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">presets</span>: [</span><br><span class="line">          [</span><br><span class="line">            <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">              <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">              <span class="attr">targets</span>: &#123;</span><br><span class="line">                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 开启babel缓存</span></span><br><span class="line">        <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">        <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>作用：让某些库不打包，通过 cdn 引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js 中配置：</span></span><br><span class="line"><span class="attr">externals</span>: &#123;</span><br><span class="line">  <span class="comment">// 拒绝jQuery被打包进来(通过cdn引入，速度会快一些)</span></span><br><span class="line">  <span class="comment">// 忽略的库名 -- npm包名</span></span><br><span class="line">  <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在 index.html 中通过 cdn 引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h4><p>作用：让某些库单独打包，后直接引入到 build 中。可以在 code split 分割出 node_modules 后再用 dll 更细的分割，优化代码运行的性能。</p>
<p><em><strong>webpack.dll.js 配置：(将 jquery 单独打包)</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  node_modules的库会打包到一起，但是很多库的时候打包输出的js文件就太大了</span></span><br><span class="line"><span class="comment">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span></span><br><span class="line"><span class="comment">  当运行webpack时，默认查找webpack.config.js配置文件</span></span><br><span class="line"><span class="comment">  需求：需要运行webpack.dll.js文件</span></span><br><span class="line"><span class="comment">    --&gt; webpack --config webpack.dll.js（运行这个指令表示以这个配置文件打包）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 最终打包生成的[name] --&gt; jquery</span></span><br><span class="line">    <span class="comment">// [&#x27;jquery] --&gt; 要打包的库是jquery</span></span><br><span class="line">    <span class="attr">jquery</span>: [<span class="string">&#x27;jquery&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出出口指定</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>, <span class="comment">// name就是jquery</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll&#x27;</span>), <span class="comment">// 打包到dll目录下</span></span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 打包的库里面向外暴露出去的内容叫什么名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 打包生成一个manifest.json --&gt; 提供jquery的映射关系（告诉webpack：jquery之后不需要再打包和暴露内容的名称）</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 映射库的暴露的内容名称</span></span><br><span class="line">      <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>) <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 配置：(告诉 webpack 不需要再打包 jquery，并将之前打包好的 jquery 跟其他打包好的资源一同输出到 build 目录下)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins中配置：</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 告诉webpack哪些库不参与打包，同时使用时的名称也得变</span></span><br><span class="line">  <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    <span class="attr">manifest</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 将某个文件打包输出到build目录下，并在html中自动引入该资源</span></span><br><span class="line">  <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">filepath</span>: resolve(__dirname, <span class="string">&#x27;dll/jquery.js&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="优化代码运行的性能"><a href="#优化代码运行的性能" class="headerlink" title="优化代码运行的性能"></a>优化代码运行的性能</h3><h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h4><p>作用：去除源代码中的无用代码，减少代码体积。</p>
<p>前提：1. 必须使用 ES6 模块化 2. 开启 production 环境 （这样就自动会把无用代码去掉）</p>
<p>在 package.json 中配置：<code>&quot;sideEffects&quot;: false</code> 表示所有代码都没有副作用（都可以进行 tree shaking），这样会导致的问题：可能会把 css / @babel/polyfill 文件干掉（副作用）。</p>
<p>所以可以配置：<code>&quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</code> 不会对css/less文件tree shaking处理。</p>
<h4 id="code-split（代码分割）"><a href="#code-split（代码分割）" class="headerlink" title="code split（代码分割）"></a>code split（代码分割）</h4><p>作用：将打包输出的一个大的 bundle.js 文件拆分成多个小文件，这样可以并行加载多个文件，比加载一个文件更快。</p>
<p><strong>module,chunk,bundle区分：</strong><a href="https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html">https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html</a></p>
<h5 id="多入口拆分"><a href="#多入口拆分" class="headerlink" title="多入口拆分"></a>多入口拆分</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="comment">// 多入口：有一个入口，最终输出就有一个bundle</span></span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;./src/js/test.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// [name]：取文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash:10].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h5 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>将 node_modules 中的代码单独打包（大小超过30kb）；</li>
<li>自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk(比如两个模块中都引入了jquery会被打包成单独的文件)（大小超过30kb）。</li>
</ul>
<h5 id="import-动态导入语法"><a href="#import-动态导入语法" class="headerlink" title="import 动态导入语法"></a>import 动态导入语法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  通过js代码，让某个文件被单独打包成一个chunk</span></span><br><span class="line"><span class="comment">  import动态导入语法：能将某个文件单独打包(test文件不会和index打包在同一个文件而是单独打包)</span></span><br><span class="line"><span class="comment">  webpackChunkName:指定test单独打包后文件的名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27; */</span><span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; mul, count &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 文件加载成功~</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件加载失败~&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="lazy-loading（懒加载-预加载）"><a href="#lazy-loading（懒加载-预加载）" class="headerlink" title="lazy loading（懒加载/预加载）"></a>lazy loading（懒加载/预加载）</h4><p><strong>1.懒加载：</strong>当文件需要使用时才加载（需要代码分割）。但是如果资源较大，加载时间就会较长，有延迟。</p>
<p><strong>2.正常加载：</strong>可以认为是并行加载（同一时间加载多个文件）没有先后顺序，先加载了不需要的资源就会浪费时间。</p>
<p><strong>3.预加载 prefetch（兼容性很差）：</strong>会在使用之前，提前加载。等其他资源加载完毕，浏览器空闲了，再偷偷加载这个资源。这样在使用时已经加载好了，速度很快。所以在懒加载的基础上加上预加载会更好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将import的内容放在异步回调函数中使用，点击按钮，test.js才会被加载(不会重复加载)</span></span><br><span class="line">  <span class="comment">// webpackPrefetch: true表示开启预加载</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */</span><span class="string">&#x27;./test&#x27;</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./test&#x27;</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="pwa（离线可访问技术）"><a href="#pwa（离线可访问技术）" class="headerlink" title="pwa（离线可访问技术）"></a>pwa（离线可访问技术）</h4><p>使用 serviceworker 和 workbox 技术。优点是离线也能访问，缺点是兼容性差。</p>
<p><em><strong>webpack.config.js 中配置：</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;workbox-webpack-plugin&#x27;</span>); <span class="comment">// 引入插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins中加入：</span></span><br><span class="line"><span class="keyword">new</span> WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 帮助serviceworker快速启动</span></span><br><span class="line"><span class="comment">    2. 删除旧的 serviceworker</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    生成一个 serviceworker 配置文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attr">clientsClaim</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">skipWaiting</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><em><strong>index.js 中还需要写一段代码来激活它的使用：</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. eslint不认识 window、navigator全局变量</span></span><br><span class="line"><span class="comment">    解决：需要修改package.json中eslintConfig配置</span></span><br><span class="line"><span class="comment">    &quot;env&quot;: &#123;</span></span><br><span class="line"><span class="comment">      &quot;browser&quot;: true // 支持浏览器端全局变量</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  2. sw代码必须运行在服务器上</span></span><br><span class="line"><span class="comment">    --&gt; nodejs</span></span><br><span class="line"><span class="comment">    或--&gt;</span></span><br><span class="line"><span class="comment">      npm i serve -g</span></span><br><span class="line"><span class="comment">      serve -s build 启动服务器，将打包输出的build目录下所有资源作为静态资源暴露出去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123; <span class="comment">// 处理兼容性问题</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">&#x27;/service-worker.js&#x27;</span>) <span class="comment">// 注册serviceWorker</span></span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册成功了~&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册失败了~&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack配置详情"><a href="#Webpack配置详情" class="headerlink" title="Webpack配置详情"></a>Webpack配置详情</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry: 入口起点</p>
<ol>
<li><p>string –&gt; ‘./src/index.js’，单入口</p>
<p>打包形成一个 chunk。 输出一个 bundle 文件。此时 chunk 的名称默认是 main</p>
</li>
<li><p>array –&gt; [‘./src/index.js’, ‘./src/add.js’]，多入口</p>
<p>所有入口文件最终只会形成一个 chunk，输出出去只有一个 bundle 文件。</p>
<p>（一般只用在 HMR 功能中让 html 热更新生效）</p>
</li>
<li><p>object，多入口</p>
<p>有几个入口文件就形成几个 chunk，输出几个 bundle 文件，此时 chunk 的名称是 key 值</p>
</li>
</ol>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  <span class="comment">// 文件名称（指定名称+目录）</span></span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;js/[name].js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出文件目录（将来所有资源输出的公共目录）</span></span><br><span class="line">  <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="comment">// 所有资源引入公共路径前缀 --&gt; &#x27;imgs/a.jpg&#x27; --&gt; &#x27;/imgs/a.jpg&#x27;</span></span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">chunkFilename</span>: <span class="string">&#x27;js/[name]_chunk.js&#x27;</span>, <span class="comment">// 指定非入口chunk的名称</span></span><br><span class="line">  <span class="attr">library</span>: <span class="string">&#x27;[name]&#x27;</span>, <span class="comment">// 打包整个库后向外暴露的变量名</span></span><br><span class="line">  <span class="attr">libraryTarget</span>: <span class="string">&#x27;window&#x27;</span> <span class="comment">// 变量名添加到哪个上 browser：window</span></span><br><span class="line">  <span class="comment">// libraryTarget: &#x27;global&#x27; // node：global</span></span><br><span class="line">  <span class="comment">// libraryTarget: &#x27;commonjs&#x27; // conmmonjs模块 exports</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    <span class="comment">// loader的配置</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 多个loader用use</span></span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="comment">// 排除node_modules下的js文件</span></span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// 只检查src下的js文件</span></span><br><span class="line">      include: resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>, <span class="comment">// 优先执行</span></span><br><span class="line">      <span class="comment">// enforce: &#x27;post&#x27;, // 延后执行</span></span><br><span class="line">      <span class="comment">// 单个loader用loader</span></span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;&#125; <span class="comment">// 指定配置选项</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 以下配置只会生效一个</span></span><br><span class="line">      <span class="attr">oneOf</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析模块的规则</span></span><br><span class="line"><span class="attr">resolve</span>: &#123;</span><br><span class="line">  <span class="comment">// 配置解析模块路径别名: 优点：当目录层级很复杂时，简写路径；缺点：路径不会提示</span></span><br><span class="line">  <span class="attr">alias</span>: &#123;</span><br><span class="line">    <span class="attr">$css</span>: resolve(__dirname, <span class="string">&#x27;src/css&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置省略文件路径的后缀名（引入时就可以不写文件后缀名了）</span></span><br><span class="line">  <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>],</span><br><span class="line">  <span class="comment">// 告诉 webpack 解析模块应该去找哪个目录</span></span><br><span class="line">  <span class="attr">modules</span>: [resolve(__dirname, <span class="string">&#x27;../../node_modules&#x27;</span>), <span class="string">&#x27;node_modules&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样配置后，引入文件就可以这样简写：<code>import &#39;$css/index&#39;;</code></p>
<h2 id="dev-server"><a href="#dev-server" class="headerlink" title="dev server"></a>dev server</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 运行代码所在的目录</span></span><br><span class="line">  <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="comment">// 监视contentBase目录下的所有文件，一旦文件变化就会reload</span></span><br><span class="line">  <span class="attr">watchContentBase</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">    <span class="comment">// 忽略文件</span></span><br><span class="line">    <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 启动gzip压缩</span></span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 端口号</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="comment">// 域名</span></span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="comment">// 自动打开浏览器</span></span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 开启HMR功能</span></span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 不要显示启动服务器日志信息</span></span><br><span class="line">  <span class="attr">clientLogLevel</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="comment">// 除了一些基本信息外，其他内容都不要显示</span></span><br><span class="line">  <span class="attr">quiet</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 如果出错了，不要全屏提示</span></span><br><span class="line">  <span class="attr">overlay</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 服务器代理，--&gt; 解决开发环境跨域问题</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="comment">// 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到另外一个服务器3000</span></span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">      <span class="comment">// 发送请求时，请求路径重写：将/api/xxx --&gt; /xxx （去掉/api）</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="optimization-1"><a href="#optimization-1" class="headerlink" title="optimization"></a>optimization</h2><p>contenthash 缓存会导致一个问题：修改 a 文件导致 b 文件 contenthash 变化。<br>因为在 index.js 中引入 a.js，打包后 index.js 中记录了 a.js 的 hash 值，而 a.js 改变，其重新打包后的 hash 改变，导致 index.js 文件内容中记录的 a.js 的 hash 也改变，从而重新打包后 index.js 的 hash 值也会变，这样就会使缓存失效。（改变的是a.js文件但是 index.js 文件的 hash 值也改变了）<br>解决办法：runtimeChunk –&gt; 将当前模块记录其他模块的 hash 单独打包为一个文件 runtime，这样 a.js 的 hash 改变只会影响 runtime 文件，不会影响到 index.js 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash:10].js&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="attr">chunkFilename</span>: <span class="string">&#x27;js/[name].[contenthash:10]_chunk.js&#x27;</span> <span class="comment">// 指定非入口文件的其他chunk的名字加_chunk</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 以下都是splitChunks默认配置，可以不写</span></span><br><span class="line"><span class="comment">    miniSize: 30 * 1024, // 分割的chunk最小为30kb（大于30kb的才分割）</span></span><br><span class="line"><span class="comment">    maxSize: 0, // 最大没有限制</span></span><br><span class="line"><span class="comment">    minChunks: 1, // 要提取的chunk最少被引用1次</span></span><br><span class="line"><span class="comment">    maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量为5</span></span><br><span class="line"><span class="comment">    maxInitialRequests: 3, // 入口js文件最大并行请求数量</span></span><br><span class="line"><span class="comment">    automaticNameDelimiter: &#x27;~&#x27;, // 名称连接符</span></span><br><span class="line"><span class="comment">    name: true, // 可以使用命名规则</span></span><br><span class="line"><span class="comment">    cacheGroups: &#123; // 分割chunk的组</span></span><br><span class="line"><span class="comment">      vendors: &#123;</span></span><br><span class="line"><span class="comment">        // node_modules中的文件会被打包到vendors组的chunk中，--&gt; vendors~xxx.js</span></span><br><span class="line"><span class="comment">        // 满足上面的公共规则，大小超过30kb、至少被引用一次</span></span><br><span class="line"><span class="comment">        test: /[\\/]node_modules[\\/]/,</span></span><br><span class="line"><span class="comment">        // 优先级</span></span><br><span class="line"><span class="comment">        priority: -10</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      default: &#123;</span></span><br><span class="line"><span class="comment">        // 要提取的chunk最少被引用2次</span></span><br><span class="line"><span class="comment">        minChunks: 2,</span></span><br><span class="line"><span class="comment">        prority: -20,</span></span><br><span class="line"><span class="comment">        // 如果当前要打包的模块和之前已经被提取的模块是同一个，就会复用，而不是重新打包</span></span><br><span class="line"><span class="comment">        reuseExistingChunk: true</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 将index.js记录的a.js的hash值单独打包到runtime文件中</span></span><br><span class="line">  <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="function"><span class="params">entrypoint</span> =&gt;</span> <span class="string">`runtime-<span class="subst">$&#123;entrypoint.name&#125;</span>`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">minimizer</span>: [</span><br><span class="line">    <span class="comment">// 配置生产环境的压缩方案：js/css</span></span><br><span class="line">    <span class="keyword">new</span> TerserWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 开启多进程打包</span></span><br><span class="line">      <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 启用sourceMap(否则会被压缩掉)</span></span><br><span class="line">      <span class="attr">sourceMap</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>资源构建打包工具</category>
      </categories>
      <tags>
        <tag>打包工具</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/JS%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<p>主要记录一下JS中一些基本但是不太容易理解的概念知识。</p>
<h4 id="·-调用栈与执行上下文"><a href="#·-调用栈与执行上下文" class="headerlink" title="· 调用栈与执行上下文"></a>· 调用栈与执行上下文</h4><p>当一段JS代码被执行，JS引擎先会进行编译，并且创建执行上下文。有以下三种情况可以被算作是“一段代码”。</p>
<ol>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure>

<p>引擎首先会创建全局执行上下文，包含声明的变量和函数。</p>
<img src="https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png" alt="组件层级示例" style="zoom:50%;" />

<p>之后当执行到add()时，JS判断出是函数调用，会：</p>
<ol>
<li>首先，从全局执行上下文中，取出 add 函数代码。</li>
<li>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li>
<li>最后，执行代码，输出结果。</li>
</ol>
<p><strong>执行上下文中包括哪些？</strong></p>
<ol>
<li><strong>变量环境：</strong></li>
</ol>
<p>首先简单说明一下变量提升的概念。</p>
<p>当我们声明了一个变量或者函数时，我们可以把他看做是声明+赋值两部分组成；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;1111&#x27;</span></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">var</span> myname；<span class="comment">// 声明</span></span><br><span class="line">myname = <span class="string">&#x27;1111&#x27;</span>  <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量 bar，再把function()&#123;console.log(&#x27;bar&#x27;)&#125;赋值给 bar。</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p>
<p>变量提升是在编译阶段被JS引擎放入内存。具体如下图：</p>
<img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png" alt="组件层级示例" style="zoom: 67%;" />



<p>如上图，输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。而通过var声明的变量和函数会被放到变量环境中。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</p>
</li>
<li><p> 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。即函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</p>
</li>
</ol>
<ol start="2">
<li><strong>词法环境：</strong></li>
</ol>
<p>ES6引入let,const使得JS也拥有了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在执行到代码块里面时，函数上下文如下图：</p>
<img src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png" alt="组件层级示例" style="zoom:50%;" />

<p>其实在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>下面是变量查找的过程：</p>
<img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" alt="组件层级示例" style="zoom: 50%;" />



<ol start="3">
<li><strong>outer</strong></li>
</ol>
<p>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，称为outer。在查找变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。以此类推，称为作用域链。</p>
<p>而JS执行过程中，其作用域链是由词法作用域决定的。词法作用域就是指<strong>作用域是由代码中函数声明的位置</strong>来决定的，所以词法作用域是静态的作用域。也就是说，<strong>词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p>
<p>通过作用域链可以更深刻的来理解闭包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot;极客时间&quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot;极客邦&quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>当执行到foo函数内部的return innerBar这行代码时，调用栈情况如下：</p>
<img src="https://static001.geekbang.org/resource/image/d5/ef/d5587b76427a56c5f0b0571e4264b7ef.png" alt="组件层级示例" style="zoom:50%;" />

<p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/ee/3f/ee7c1ca481875ad4bdeb4383bd1f883f.png" alt="组件层级示例" style="zoom:50%;" />



<p><strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</strong></p>
<p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的myName = “极客邦”这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，可以参考下面的调用栈状态图：</p>
<img src="https://static001.geekbang.org/resource/image/50/46/50e4ba60fc7e420e83b35b95e379b246.png" alt="组件层级示例" style="zoom:50%;" />



<ol start="4">
<li><strong>this</strong></li>
</ol>
<p>this和执行上下文是绑定的，每个执行上下文中都有一个 this。执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p>
<p><strong>全局执行上下文的this:</strong></p>
<p>全局执行上下文中的 this 指向 window 对象。</p>
<p><strong>函数执行上下文的this:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。</p>
<p>下面是三种来设置函数执行上下文的this值。</p>
<ol>
<li><strong>通过call,apply,bind方法设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">  <span class="attr">test1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar) </span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">//kkk</span></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>通过对象调用方式设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis() <span class="comment">//lol</span></span><br></pre></td></tr></table></figure>

<p>即： <strong>使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。</strong></p>
<p>也可以认为是JS引擎在执行myObject.showThis()时，将其转化为了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObj.showThis.call(myObj)</span><br></pre></td></tr></table></figure>

<p>但是如果我们把一个对象的方法赋值给一个全局对象，然后再调用该对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window, 因为此时相当于在全局环境调用一个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj.showThis</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>通过构造函数方式设置this</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;lol&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> CreateObj()</span><br></pre></td></tr></table></figure>

<p>当执行new Createobj()时，JS引擎做了以下几件事：</p>
<ol>
<li>首先创建了一个空对象 tempObj；</li>
<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li>
<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>
<li>最后返回 tempObj 对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>



<p><strong>this的缺陷</strong></p>
<ol>
<li><strong>嵌套函数中的 this 不会从外层函数中继承</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>执行这段代码后，函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</p>
<p>可以通过一个小技巧来解决这个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      self.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name) <span class="comment">//zzz</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<strong>箭头函数</strong>来解决该问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p>
<ol start="2">
<li><strong>普通函数中的 this 默认指向全局对象 window</strong></li>
</ol>
<p>这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。</p>
<p>可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。</p>
<h4 id="·-总结"><a href="#·-总结" class="headerlink" title="· 总结"></a>· 总结</h4><p>本文主要梳理了一下函数调用栈和执行上下文，以及上下文中包含的四块内容的相关知识点，此为JS的基础知识，需要深刻理解。</p>
]]></content>
  </entry>
</search>
