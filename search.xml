<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS概念知识</title>
    <url>/JS%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<p>主要记录一下JS中一些基本但是不太容易理解的概念知识。</p>
<span id="more"></span>



<h4 id="·-调用栈与执行上下文"><a href="#·-调用栈与执行上下文" class="headerlink" title="· 调用栈与执行上下文"></a>· 调用栈与执行上下文</h4><p>当一段JS代码被执行，JS引擎先会进行编译，并且创建执行上下文。有以下三种情况可以被算作是“一段代码”。</p>
<ol>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure>

<p>引擎首先会创建全局执行上下文，包含声明的变量和函数。</p>
<img src="https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png" alt="组件层级示例" style="zoom:50%;" />

<p>之后当执行到add()时，JS判断出是函数调用，会：</p>
<ol>
<li>首先，从全局执行上下文中，取出 add 函数代码。</li>
<li>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li>
<li>最后，执行代码，输出结果。</li>
</ol>
<p><strong>执行上下文中包括哪些？</strong></p>
<ol>
<li><strong>变量环境：</strong></li>
</ol>
<p>首先简单说明一下变量提升的概念。</p>
<p>当我们声明了一个变量或者函数时，我们可以把他看做是声明+赋值两部分组成；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;1111&#x27;</span></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">var</span> myname；<span class="comment">// 声明</span></span><br><span class="line">myname = <span class="string">&#x27;1111&#x27;</span>  <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量 bar，再把function()&#123;console.log(&#x27;bar&#x27;)&#125;赋值给 bar。</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p>
<p>变量提升是在编译阶段被JS引擎放入内存。具体如下图：</p>
<img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png" alt="组件层级示例" style="zoom: 67%;" />



<p>如上图，输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。而通过var声明的变量和函数会被放到变量环境中。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</p>
</li>
<li><p> 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。即函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</p>
</li>
</ol>
<ol start="2">
<li><strong>词法环境：</strong></li>
</ol>
<p>ES6引入let,const使得JS也拥有了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在执行到代码块里面时，函数上下文如下图：</p>
<img src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png" alt="组件层级示例" style="zoom:50%;" />

<p>其实在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>下面是变量查找的过程：</p>
<img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" alt="组件层级示例" style="zoom: 50%;" />



<ol start="3">
<li><strong>outer</strong></li>
</ol>
<p>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，称为outer。在查找变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。以此类推，称为作用域链。</p>
<p>而JS执行过程中，其作用域链是由词法作用域决定的。词法作用域就是指<strong>作用域是由代码中函数声明的位置</strong>来决定的，所以词法作用域是静态的作用域。也就是说，<strong>词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p>
<p>通过作用域链可以更深刻的来理解闭包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot;极客时间&quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot;极客邦&quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>当执行到foo函数内部的return innerBar这行代码时，调用栈情况如下：</p>
<img src="https://static001.geekbang.org/resource/image/d5/ef/d5587b76427a56c5f0b0571e4264b7ef.png" alt="组件层级示例" style="zoom:50%;" />

<p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/ee/3f/ee7c1ca481875ad4bdeb4383bd1f883f.png" alt="组件层级示例" style="zoom:50%;" />



<p><strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</strong></p>
<p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的myName = “极客邦”这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，可以参考下面的调用栈状态图：</p>
<img src="https://static001.geekbang.org/resource/image/50/46/50e4ba60fc7e420e83b35b95e379b246.png" alt="组件层级示例" style="zoom:50%;" />



<ol start="4">
<li><strong>this</strong></li>
</ol>
<p>this和执行上下文是绑定的，每个执行上下文中都有一个 this。执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p>
<p><strong>全局执行上下文的this:</strong></p>
<p>全局执行上下文中的 this 指向 window 对象。</p>
<p><strong>函数执行上下文的this:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。</p>
<p>下面是三种来设置函数执行上下文的this值。</p>
<ol>
<li><strong>通过call,apply,bind方法设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">  <span class="attr">test1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar) </span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">//kkk</span></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>通过对象调用方式设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis() <span class="comment">//lol</span></span><br></pre></td></tr></table></figure>

<p>即： <strong>使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。</strong></p>
<p>也可以认为是JS引擎在执行myObject.showThis()时，将其转化为了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObj.showThis.call(myObj)</span><br></pre></td></tr></table></figure>

<p>但是如果我们把一个对象的方法赋值给一个全局对象，然后再调用该对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window, 因为此时相当于在全局环境调用一个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj.showThis</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>通过构造函数方式设置this</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;lol&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> CreateObj()</span><br></pre></td></tr></table></figure>

<p>当执行new Createobj()时，JS引擎做了以下几件事：</p>
<ol>
<li>首先创建了一个空对象 tempObj；</li>
<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li>
<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>
<li>最后返回 tempObj 对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>



<p><strong>this的缺陷</strong></p>
<ol>
<li><strong>嵌套函数中的 this 不会从外层函数中继承</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>执行这段代码后，函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</p>
<p>可以通过一个小技巧来解决这个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      self.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name) <span class="comment">//zzz</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<strong>箭头函数</strong>来解决该问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p>
<ol start="2">
<li><strong>普通函数中的 this 默认指向全局对象 window</strong></li>
</ol>
<p>这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。</p>
<p>可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。</p>
<h4 id="·-总结"><a href="#·-总结" class="headerlink" title="· 总结"></a>· 总结</h4><p>本文主要梳理了一下函数调用栈和执行上下文，以及上下文中包含的四块内容的相关知识点，此为JS的基础知识，需要深刻理解。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title>节流和防抖</title>
    <url>/debounce&amp;throttle/</url>
    <content><![CDATA[<p>最近在项目中用到了节流，在这里总结一下防抖和节流，以及一些闭包的知识。</p>
<span id="more"></span>

<h1 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h1><p><strong>定义：</strong>在事件被触发n秒后再执行回调，如果在n秒内又被触发，就重新计时。其实就是某一段时间内只执行一次。</p>
<p>举个例子，现在实现一个功能，在输入框中输入一个字符，先显示waiting ，延迟1秒后在下方输出这个字符，类似于百度输入框。</p>
<p>如果不使用防抖的话，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params">text</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=text.target.value</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    <span class="keyword">let</span> timeout;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        	showInfo(e)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,delay)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=<span class="string">&#x27;waiting&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200404221805681.gif" alt="不使用防抖的结果"></p>
<p><strong>原因就是：</strong>当我们多次输入，就会多次调用回调函数，就会将多个定时器加入宏任务队列，每一个都是1s后执行，那这样就会交叉显示了，看起来很抖，如果每一次都得请求接口的话，就会资源浪费而且耗时。</p>
<p>下面看一下用防抖的结果，思路就是在下一次调用函数的时候，把上一次的定时器关掉。这样其实有两种做法，我们需要维护一个变量用来保存每次开启的定时器，可以采用全局变量保存，或者使用闭包。</p>
<p>看看全局变量的做法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> timeout;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       	showInfo(e)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       &#125;, <span class="number">1000</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,delay)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=<span class="string">&#x27;waiting&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200404223448631.gif" alt="不使用闭包实现防抖"></p>
<p><em>之后会说一下为什么不使用闭包的话，timeout变量必须是全局。</em></p>
<p>再来看看使用闭包的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params">text</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=text.target.value</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    <span class="keyword">let</span> timeout;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	            func.apply(context, args)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	        &#125;, wait);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,debounce(showInfo,<span class="number">1000</span>))</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>).addEventListener(<span class="string">&#x27;input&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML=<span class="string">&#x27;waiting&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>那么为什么不使用闭包的话，必须设置为全局变量呢？</strong></p>
<p>其实javascript里的全局定义的变量，即使程序之后没有用到它，也还是不会被内存回收，是一直存在的，而存在于函数中的局部变量，当函数被调用时，会在内存中开辟空间用来存放函数中定义的局部变量(函数也是)，但是当函数执行完毕后，这些变量都会被回收，也就是说，无论我们对一个函数重复调用多少次，每一次都是创建新的变量，开辟新的空间，之间没有任何联系。</p>
<p>那么有没有办法可以在函数调用完后，将里面的变量保存下来呢？这就得用到闭包了。javascript会在函数调用完成之后回收变量空间的原因，是因为这些变量没有被外界使用或者引用，如果我们可以定义一个外界(全局)的变量，接收到函数里面某个变量的值，即函数内部的变量被引用，那么即使在函数被调用之后，由于外界还存在引用，整个函数里的变量的状态都会被保存。</p>
<p>一般的做法就是在函数内部返回一个函数，然后外界创建一个变量接收，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Outer</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    n ++;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Outer(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>当我们多次调用a的时候，就会实现n的累加，因为每一次调用的n都是第一次调用时候创建的那个，实现了变量的状态保持。</p>
<p><strong>所以这里使用闭包的好处就是：</strong></p>
<ol>
<li>可以避免全局变量污染作用域，就像上面的代码，不使用闭包的话，就得定义全局变量维持状态，会造成污染。污染是什么意思？</li>
</ol>
<p>我理解的大概是：一是会命名冲突；二是我们定义的全局变量都会挂载在window上，变成属性和方法，这样每次项目启动运行的时候就会造成加载方面的问题(太深入的还没研究~)</p>
<ol>
<li>如果一个页面上需要多个防抖函数，那么我们得写很多重复的代码，没有实现函数的封装复用。</li>
</ol>
<p><em><strong>使用场景：</strong></em></p>
<ol>
<li>search搜索联想，用户在输入框中不断输入值，我们只需要在用户最后一次输入后请求接口就好了。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次。</li>
</ol>
<h1 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h1><p><strong>定义：</strong>规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。</p>
<p><strong>我此次的需求就是：</strong>添加一个按钮，用户可以点击查看自己当前的进度，其实就是调后台接口进行判断，然后将结果展示，但是用户可能会频繁点击，我又不太想加禁用……，但是频繁调接口又会有一定延时，体验不太好，所以最终想要用户1min内只能请求一次接口，如果在第一次点击之后的一分钟内多次点击，给用户提示请稍后，不做其他操作。</p>
<p>我一开始的做法是维护一个全局的标志位flag，代码类似下面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> checkState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">const</span> checkParams = &#123;</span><br><span class="line">        merchant_sn,</span><br><span class="line">        dev_code,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 调接口</span></span><br><span class="line">      queryApplyStatus(checkParams).then(<span class="function">(<span class="params">&#123; data &#125;: &#123; data: any &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">          &#125;, <span class="number">1000</span> * <span class="number">60</span>);</span><br><span class="line">          <span class="keyword">const</span> &#123; contract_memo = <span class="string">&#x27;&#x27;</span>, contract_code = <span class="string">&#x27;&#x27;</span>, qrcode = <span class="string">&#x27;&#x27;</span> &#125; = data;</span><br><span class="line">         	<span class="comment">// 然后根据返回结果做一些业务处理</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;请稍后&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>其实这样写也还算能完成功能，但是看了网上相关的代码，觉得可以尝试自己封装一个节流函数，之后再遇到类似问题，直接用就好。下面是我自己封的一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">throttle = <span class="function">(<span class="params">fn, wait</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">      <span class="keyword">if</span> (nowTime - lastTime &gt; wait) &#123;</span><br><span class="line">        fn();</span><br><span class="line">        lastTime = nowTime;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        toast(<span class="string">&#x27;请勿频繁点击&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>没有用定时器去做，因为觉得有时候异步任务很多时，定时器不是准确的，所以用了时间戳去判断。网上还有更好的例子，在这里就不提供示例代码啦~</p>
<p>其实这里还有个小问题，当用户刷新的时候，保留的状态还是会被清掉，这样其实还是会出现重复请求的问题，后来的做法是将lastTime存在了SessionStorage里面(LocalStorage也是可以的，看业务场景)。</p>
<p><em><strong>使用场景：</strong></em></p>
<ol>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)；</li>
<li>监听滚动事件，比如是否滑到底部加载更多。</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS小技能</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用指令</title>
    <url>/git/</url>
    <content><![CDATA[<p>主要是记录git工作流程和归纳一下日常常用的git操作命令，防止遗忘。</p>
<span id="more"></span>

<p>git主要涉及到以下四个关键点：</p>
<p>&emsp;&emsp;<strong>工作区</strong>：本地电脑存放项目文件的地方；</p>
<p>&emsp;&emsp;<strong>暂存区（Index/Stage）</strong>：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版                                                    本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文                                                    件的地方，通常使用add命令将工作区的文件添加到暂存区里；</p>
<p>&emsp;&emsp;<strong>本地仓库：</strong>.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中                          的文件添加到本地仓库中；</p>
<p>&emsp;&emsp;<strong>远程仓库：</strong>不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将                          远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fcc0e7e711dc7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="git几个核心区域间的关系"></p>
<p>所以其实git命令可以划分为以下：</p>
<ol>
<li><strong>git管理配置的命令；</strong></li>
<li><strong>工作区与暂存区的交互；</strong></li>
<li><strong>暂存区与本地仓库（分支）上的交互；</strong></li>
<li><strong>本地仓库与远程仓库的交互。</strong></li>
</ol>
<p>&emsp;</p>
<h2 id="git配置相关"><a href="#git配置相关" class="headerlink" title="git配置相关"></a>git配置相关</h2><ol>
<li><strong>配置用户名和邮箱：</strong></li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;your name&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;youremail@github.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;</p>
<h2 id="工作区上的操作命令"><a href="#工作区上的操作命令" class="headerlink" title="工作区上的操作命令"></a>工作区上的操作命令</h2><h3 id="·-新建仓库"><a href="#·-新建仓库" class="headerlink" title="· 新建仓库"></a><strong>· 新建仓库</strong></h3><ol>
<li><p>将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure></li>
<li><p>从远程git仓库复制项目，克隆项目时如果想定义新的项目名，可以在指令后面指定：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone git:<span class="regexp">//gi</span>thub.com<span class="regexp">/wasd/</span>example.git mygit</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-提交"><a href="#·-提交" class="headerlink" title="· 提交"></a><strong>· 提交</strong></h3><ol>
<li><p>提交工作区所有文件到暂存区</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> .</span><br></pre></td></tr></table></figure></li>
<li><p>提交指定文件到暂存区</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">add</span> <span class="symbol">&lt;file1&gt;</span> <span class="symbol">&lt;file2&gt;</span> ...</span><br></pre></td></tr></table></figure></li>
<li><p>提交工作区中某个文件夹中所有文件到暂存区</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git <span class="builtin-name">add</span> [dir]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-撤销"><a href="#·-撤销" class="headerlink" title="· 撤销"></a><strong>· 撤销</strong></h3><ol>
<li><p>删除工作区文件，并从暂存区删除对应文件的记录</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> rm &lt;file<span class="number">1</span>&gt; &lt;file<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从暂存区删除文件，但是工作区依然还有该文件</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">rm</span> --cached &lt;<span class="keyword">file</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>取消暂存区已经暂存的文件</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">git <span class="meta">reset</span> HEAD &lt;<span class="meta">file</span>&gt;...</span><br></pre></td></tr></table></figure></li>
<li><p>撤销上一次对文件的操作</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">--&lt;file&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <em>要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理</em></p>
</li>
</ol>
<h3 id="·-更新文件"><a href="#·-更新文件" class="headerlink" title="· 更新文件"></a><strong>· 更新文件</strong></h3><ol>
<li><p>重命名文件，并将已改名文件提交到暂存区</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git mv [<span class="built_in">file</span>-original] [<span class="built_in">file</span>-renamed]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-查询状态"><a href="#·-查询状态" class="headerlink" title="· 查询状态"></a><strong>· 查询状态</strong></h3><ol>
<li><p>查询当前工作区所有文件的状态</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容(也可以指定文件)</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git diff &lt;<span class="built_in">file</span>-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h2 id="暂存区上的操作命令"><a href="#暂存区上的操作命令" class="headerlink" title="暂存区上的操作命令"></a>暂存区上的操作命令</h2><h3 id="·-提交文件到版本库"><a href="#·-提交文件到版本库" class="headerlink" title="· 提交文件到版本库"></a><strong>· 提交文件到版本库</strong></h3><ol>
<li><p>将暂存区中的文件提交到本地仓库，打上新版本</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&quot;commit_info&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">&quot;commit_info&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-查看信息"><a href="#·-查看信息" class="headerlink" title="· 查看信息"></a><strong>· 查看信息</strong></h3><ol>
<li><p>比较暂存区与上一版本的差异</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git diff &lt;<span class="built_in">file</span>-<span class="built_in">name</span>&gt; <span class="comment">--cached</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看提交历史，参数-p展开每次提交的历史差异，用-2显示最近的两次更新</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p -<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-打标签"><a href="#·-打标签" class="headerlink" title="· 打标签"></a><strong>· 打标签</strong></h3><p>​            有两种类型：<strong>轻量级的（lightweight）和含附注的（annotated）</strong>。轻量级标签就像是个不会变化的分支，实际上它就是个指向    特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件    地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般建议使用含附注型的标签，以便保    留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也行。</p>
<ol>
<li><p>列出现在所有的标签</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用特定的搜索模式列出符合条件的标签，例如只对1.4.2系列的版本感兴趣</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-l</span> <span class="string">&quot;v1.4.2.*&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个含附注类型的标签，需要加<code>-a</code>参数</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> v1.<span class="number">4</span> -m <span class="string">&quot;my version 1.4&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用git show命令查看相应标签的版本信息，并连同显示打标签时的提交对象</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> show v<span class="number">1</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个轻量级标签的话，就直接使用git tag命令即可，连<code>-a</code>,<code>-s</code>以及<code>-m</code>选项都不需要，直接给出标签名字即可</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>将标签推送到远程仓库中</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> push origin v<span class="number">1</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>将本地所有的标签全部推送到远程仓库中</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="·-分支管理"><a href="#·-分支管理" class="headerlink" title="· 分支管理"></a><strong>· 分支管理</strong></h3><ol>
<li><p>创建分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从当前所处的分支切换到其他分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>新建并切换到新建分支上</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>将当前分支与指定分支进行合并</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">merge</span> &lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>显示本地仓库的所有分支</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看各个分支最后一个提交对象的信息</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch -v</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看哪些分支已经合并到当前分支</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git branch <span class="comment">--merged</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看当前哪些分支还没有合并到当前分支</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> branch --<span class="literal">no</span>-merged</span><br></pre></td></tr></table></figure></li>
<li><p>把远程分支合并到当前分支</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">merge</span> &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​        <em>如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；</em><em><strong>(不是特别理解这段话的意思)</strong></em></p>
</li>
<li><p>在远程分支的基础上创建新的本地分支</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-<span class="built_in">name</span>&gt; &lt;remote-<span class="built_in">name</span>&gt;/&lt;branch-<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>从远程分支checkout出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容, 该命令会自动判断应该向远程仓库中的哪个分支推送数据.</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure>

<p>在跟踪分支上合并远程分支</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git pull</span></span><br></pre></td></tr></table></figure></li>
<li><p>关于rebase的操作目前还不太理解，先不写在里面啦~</p>
</li>
</ol>
<p>&emsp;</p>
<h2 id="本地仓库上的操作"><a href="#本地仓库上的操作" class="headerlink" title="本地仓库上的操作"></a>本地仓库上的操作</h2><ol>
<li><p>查看本地仓库关联的远程仓库</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote</span></span><br></pre></td></tr></table></figure>

<p><em>在克隆完每个远程仓库后，远程仓库默认为 orign，加上<code>-v</code>的参数后，会显示远程仓库的<code>url</code>地址；</em></p>
</li>
<li><p>添加远程仓库，一般会取一个简短的别名</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git remote add example git:<span class="regexp">//gi</span>thub.com<span class="regexp">/example/</span>example.git</span><br></pre></td></tr></table></figure></li>
<li><p>从远程仓库中抓取本地仓库中没有的更新</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">fetch</span> [remote-<span class="type">name</span>]</span><br></pre></td></tr></table></figure>

<p><em>使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用<code>git pull</code>来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；</em></p>
</li>
<li><p>将本地仓库某分支推送到远程仓库上</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git push [remote-<span class="built_in">name</span>] [branch-<span class="built_in">name</span>]</span><br></pre></td></tr></table></figure>

<p>如果想将本地分支推送到远程仓库的不同名分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;local-branch&gt;<span class="symbol">:&lt;remote-branch&gt;</span></span><br><span class="line">如：</span><br><span class="line">git push origin <span class="symbol">serverfix:</span>awesomebranch</span><br></pre></td></tr></table></figure>

<p>如果想删除远程分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push [romote-name] <span class="symbol">:&lt;remote-branch&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。</em></p>
</li>
<li><p>查看远程仓库的详细信息</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">show</span> <span class="built_in">origin</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改某个远程仓库在本地的简称</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">rename</span> [<span class="built_in">old</span>-<span class="type">name</span>] [<span class="built_in">new</span>-<span class="type">name</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>移除远程仓库</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> remote rm<span class="meta"> [remote-name]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;</p>
<h2 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件.gitignore"></a>忽略文件.gitignore</h2><p>​        一般会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此为注释 – 将被 Git 忽略</span></span><br><span class="line"><span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">*<span class="string">.a</span></span><br><span class="line"><span class="comment"># 但 lib.a 除外</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*<span class="string">.txt</span></span><br><span class="line"><span class="comment"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span></span><br><span class="line">doc/**/*<span class="string">.txt</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks</title>
    <url>/reactHooks/</url>
    <content><![CDATA[<p>主要记录一下JS中一些基本但是不太容易理解的概念知识。</p>
<span id="more"></span>

<h3 id="·-调用栈与执行上下文"><a href="#·-调用栈与执行上下文" class="headerlink" title="· 调用栈与执行上下文"></a>· 调用栈与执行上下文</h3><p>当一段JS代码被执行，JS引擎先会进行编译，并且创建执行上下文。有以下三种情况可以被算作是“一段代码”。</p>
<ol>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure>

<p>引擎首先会创建全局执行上下文，包含声明的变量和函数。</p>
<img src="https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png" alt="组件层级示例" style="zoom:50%;" />

<p>之后当执行到add()时，JS判断出是函数调用，会：</p>
<ol>
<li>首先，从全局执行上下文中，取出 add 函数代码。</li>
<li>其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li>
<li>最后，执行代码，输出结果。</li>
</ol>
<p><strong>执行上下文中包括哪些？</strong></p>
<ol>
<li><strong>变量环境：</strong></li>
</ol>
<p>首先简单说明一下变量提升的概念。</p>
<p>当我们声明了一个变量或者函数时，我们可以把他看做是声明+赋值两部分组成；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;1111&#x27;</span></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">var</span> myname；<span class="comment">// 声明</span></span><br><span class="line">myname = <span class="string">&#x27;1111&#x27;</span>  <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个函数 foo 是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量 bar，再把function()&#123;console.log(&#x27;bar&#x27;)&#125;赋值给 bar。</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p>
<p>变量提升是在编译阶段被JS引擎放入内存。具体如下图：</p>
<img src="https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png" alt="组件层级示例" style="zoom: 67%;" />



<p>如上图，输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。而通过var声明的变量和函数会被放到变量环境中。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</p>
</li>
<li><p> 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。即函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</p>
</li>
</ol>
<ol start="2">
<li><strong>词法环境：</strong></li>
</ol>
<p>ES6引入let,const使得JS也拥有了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">      <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b) </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">    <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;   </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在执行到代码块里面时，函数上下文如下图：</p>
<img src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png" alt="组件层级示例" style="zoom:50%;" />

<p>其实在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p>下面是变量查找的过程：</p>
<img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" alt="组件层级示例" style="zoom: 50%;" />



<ol start="3">
<li><strong>outer</strong></li>
</ol>
<p>在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，称为outer。在查找变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。以此类推，称为作用域链。</p>
<p>而JS执行过程中，其作用域链是由词法作用域决定的。词法作用域就是指<strong>作用域是由代码中函数声明的位置</strong>来决定的，所以词法作用域是静态的作用域。也就是说，<strong>词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p>
<p>通过作用域链可以更深刻的来理解闭包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">&quot;极客时间&quot;</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            myName = newName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo()</span><br><span class="line">bar.setName(<span class="string">&quot;极客邦&quot;</span>)</span><br><span class="line">bar.getName()</span><br><span class="line"><span class="built_in">console</span>.log(bar.getName())</span><br></pre></td></tr></table></figure>

<p>当执行到foo函数内部的return innerBar这行代码时，调用栈情况如下：</p>
<img src="https://static001.geekbang.org/resource/image/d5/ef/d5587b76427a56c5f0b0571e4264b7ef.png" alt="组件层级示例" style="zoom:50%;" />

<p>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/ee/3f/ee7c1ca481875ad4bdeb4383bd1f883f.png" alt="组件层级示例" style="zoom:50%;" />



<p><strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</strong></p>
<p>那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的myName = “极客邦”这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：</p>
<img src="https://static001.geekbang.org/resource/image/50/46/50e4ba60fc7e420e83b35b95e379b246.png" alt="组件层级示例" style="zoom:50%;" />



<ol start="4">
<li><strong>this</strong></li>
</ol>
<p>this和执行上下文是绑定的，每个执行上下文中都有一个 this。执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p>
<p><strong>全局执行上下文的this:</strong></p>
<p>全局执行上下文中的 this 指向 window 对象。</p>
<p><strong>函数执行上下文的this:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。</p>
<p>下面是三种来设置函数执行上下文的this值。</p>
<ol>
<li><strong>通过call,apply,bind方法设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot;zzz&quot;</span>,</span><br><span class="line">  <span class="attr">test1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(bar) </span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">//kkk</span></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>通过对象调用方式设置</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis() <span class="comment">//lol</span></span><br></pre></td></tr></table></figure>

<p>即： <strong>使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。</strong></p>
<p>也可以认为是JS引擎在执行myObject.showThis()时，将其转化为了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObj.showThis.call(myObj)</span><br></pre></td></tr></table></figure>

<p>但是如果我们把一个对象的方法赋值给一个全局对象，然后再调用该对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;kkk&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//window, 因为此时相当于在全局环境调用一个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj.showThis</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>通过构造函数方式设置this</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;lol&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> CreateObj()</span><br></pre></td></tr></table></figure>

<p>当执行new Createobj()时，JS引擎做了以下几件事：</p>
<ol>
<li>首先创建了一个空对象 tempObj；</li>
<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li>
<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>
<li>最后返回 tempObj 对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line">CreateObj.call(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>



<p><strong>this的缺陷</strong></p>
<ol>
<li><strong>嵌套函数中的 this 不会从外层函数中继承</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br></pre></td></tr></table></figure>

<p>执行这段代码后，函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。</p>
<p>可以通过一个小技巧来解决这个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      self.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name) <span class="comment">//zzz</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<strong>箭头函数</strong>来解决该问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;lol&quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot;zzz&quot;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.showThis()</span><br><span class="line"><span class="built_in">console</span>.log(myObj.name)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)</span><br></pre></td></tr></table></figure>

<p>这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。</p>
<ol start="2">
<li><strong>普通函数中的 this 默认指向全局对象 window</strong></li>
</ol>
<p>这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。</p>
<p>可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。</p>
<h4 id="·-总结"><a href="#·-总结" class="headerlink" title="· 总结"></a>· 总结</h4><p>本文主要梳理了一下函数调用栈和执行上下文，以及上下文中包含的四块内容的相关知识点，此为JS的基础知识，需要深刻理解。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack基础知识</title>
    <url>/webpack/</url>
    <content><![CDATA[<p>本文主要是总结一下近期看的webpack文档及视频里面的知识点，暂不涉及内部原理和源码分析，持续完善。</p>
<span id="more"></span>



<h1 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a><strong>Webpack是什么</strong></h1><p>​        webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在 webpack 看来, 前端的所有资源文件都会作为模块处理。 它将根据模块的依赖关系进行静态分析，在内部构建依赖图，打包生成对应的静态资源(bundle)。 </p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h1><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>​            打包入口，指示webpack以哪个文件(可以有多个)为入口起点开始打包，然后会找出有哪些模块和库是入口起点(直接或间接)            依赖的。默认值是./src/index.js。 </p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>​             告诉webpack在哪里输出所创建的bundle，以及如何命名这些文件。主要输出文件的默认值为./dist/main.js。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>​                因为webpack本身只理解js文件和JSON文件，所以需要loader去将其他类型的文件转换为webpack可理解的有效模块。</p>
<p>​                两个属性：</p>
<p>​                  1. test: 识别出哪些文件会被转换；</p>
<p>​                2.use: 定义出在进行转换时，应该使用哪个 loader。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;my-first-webpack.bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>​                执行更加广泛的任务，包括：打包优化，资源管理，注入环境变量等。</p>
<p>​                使用的话，一般只需要require()它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。也可以在一        个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p>​                通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优                化。其默认值为 <code>production</code>。</p>
<p><em>webpack.config.js:</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack开发环境基本配置"><a href="#Webpack开发环境基本配置" class="headerlink" title="Webpack开发环境基本配置"></a><strong>Webpack开发环境基本配置</strong></h1><p>首先需要初始化package.json: npm init</p>
<p>下载安装webpack：(webpack4以上的版本需要全局/本地都安装webpack-cli)</p>
<p>​    <strong>全局安装：</strong> cnpm i webpack webpack-cli -g</p>
<p>​    <strong>本地安装：</strong> cnpm i webpack webpack-cli -D</p>
<p><strong>webpack的配置文件：</strong> webpack.config.js，所有构建工具都是基于 nodejs 平台运行的，模块化默认采用 commonjs。</p>
<p>开发环境主要考虑以下方面：</p>
<ul>
<li>打包样式资源</li>
<li>打包 html 资源</li>
<li>打包图片资源</li>
<li>打包其他资源</li>
<li>devServer</li>
</ul>
<p>下面是一个简单的开发环境webpack.confg.js配置文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>) <span class="comment">// 引用plugin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>, <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/build.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// __dirname是nodejs的变量，代表当前文件的目录绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>), <span class="comment">// 输出路径，所有资源打包都会输出到这个文件夹下</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细的loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 匹配哪些文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上，依次执行(先执行css-loader)</span></span><br><span class="line">          <span class="comment">// style-loader：创建style标签，将js中的样式资源插入进去，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// css-loader：将css文件变成commonjs模块加载到js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// less-loader：将less文件编译成css文件，需要下载less-loader和less</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// url-loader：处理图片资源，问题：默认处理不了html中的img图片</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        <span class="comment">// 需要下载 url-loader file-loader</span></span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 图片大小小于8kb，就会被base64处理，优点：减少请求数量（减轻服务器压力），缺点：图片体积会更大（文件请求速度更慢）</span></span><br><span class="line">          <span class="comment">// base64在客户端本地解码所以会减少服务器压力，如果图片过大还采用base64编码会导致cpu调用率上升，网页加载时变卡</span></span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">// 给图片重命名，[hash:10]：取图片的hash的前10位，[ext]：取文件原来扩展名</span></span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="comment">// 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是conmonjs，解析时会出问题：[object Module]</span></span><br><span class="line">          <span class="comment">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        <span class="comment">// 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span></span><br><span class="line">        loader: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 打包其他资源(除了html/js/css资源以外的资源)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 排除html|js|css|less|jpg|png|gif文件</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class="line">        <span class="comment">// file-loader：处理其他文件</span></span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugin的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin：默认会创建一个空的html文件，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">// 需要有结构的HTML文件可以加一个template</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 复制这个./src/index.html文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// 开发服务器 devServer：用来自动化，不用每次修改后都重新输入webpack打包一遍（自动编译，自动打开浏览器，自动刷新浏览器）</span></span><br><span class="line">  <span class="comment">// 特点：只会在内存中编译打包，不会有任何输出（不会像之前那样在外面看到打包输出的build包，而是在内存中，关闭后会自动删除）</span></span><br><span class="line">  <span class="comment">// 启动devServer指令为：npx webpack-dev-server</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 项目构建后路径</span></span><br><span class="line">    <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="comment">// 启动gzip压缩</span></span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行项目的两个指令：<br>webpack 会将打包结果输出出去（build文件夹）<br>npx webpack-dev-server 只会在内存中编译打包，没有输出</p>
</li>
<li><p>loader 和 plugin 的不同：（plugin 一定要先引入才能使用）</p>
<p> loader：1. 下载 2. 使用（配置 loader）</p>
<p> plugins：1.下载 2. 引入 3. 使用</p>
</li>
</ul>
<h1 id="Webpack生产环境的基本配置"><a href="#Webpack生产环境的基本配置" class="headerlink" title="Webpack生产环境的基本配置"></a><strong>Webpack生产环境的基本配置</strong></h1><p>生产环境的配置需要考虑以下几个方面：</p>
<ul>
<li>提取 css 成单独文件</li>
<li>css 兼容性处理</li>
<li>压缩 css</li>
<li>js 语法检查</li>
<li>js 兼容性处理</li>
<li>js 压缩</li>
<li>html 压缩</li>
</ul>
<p>主要是多了一些兼容性和优化。下面是一个基本的生产环境下的webpack.config.js配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractorPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> OptimiziCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimizi-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义node.js的环境变量，决定使用browserslist的哪个环境</span></span><br><span class="line">process.env.NODE_ENV = <span class="string">&#x27;production&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复用loader的写法</span></span><br><span class="line"><span class="keyword">const</span> commonCssLoader = [</span><br><span class="line">  <span class="comment">// 这个loader取代style-loader。作用：提取js中的css成单独文件然后通过link加载</span></span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  <span class="comment">// css-loader：将css文件整合到js文件中</span></span><br><span class="line">  <span class="comment">// 经过css-loader处理后，样式文件是在js文件中的</span></span><br><span class="line">  <span class="comment">// 问题：1.js文件体积会很大2.需要先加载js再动态创建style标签，样式渲染速度就慢，会出现闪屏现象</span></span><br><span class="line">  <span class="comment">// 解决：用MiniCssExtractPlugin.loader替代style-loader</span></span><br><span class="line">  <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    postcss-loader：css兼容性处理：postcss --&gt; 需要安装：postcss-loader postcss-preset-env</span></span><br><span class="line"><span class="comment">    postcss需要通过package.json中browserslist里面的配置加载指定的css兼容性样式</span></span><br><span class="line"><span class="comment">    在package.json中定义browserslist：</span></span><br><span class="line"><span class="comment">    &quot;browserslist&quot;: &#123;</span></span><br><span class="line"><span class="comment">      // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span></span><br><span class="line"><span class="comment">      &quot;development&quot;: [ // 只需要可以运行即可</span></span><br><span class="line"><span class="comment">        &quot;last 1 chrome version&quot;,</span></span><br><span class="line"><span class="comment">        &quot;last 1 firefox version&quot;,</span></span><br><span class="line"><span class="comment">        &quot;last 1 safari version&quot;</span></span><br><span class="line"><span class="comment">      ],</span></span><br><span class="line"><span class="comment">      // 生产环境。默认是生产环境</span></span><br><span class="line"><span class="comment">      &quot;production&quot;: [ // 需要满足绝大多数浏览器的兼容</span></span><br><span class="line"><span class="comment">        &quot;&gt;0.2%&quot;,</span></span><br><span class="line"><span class="comment">        &quot;not dead&quot;,</span></span><br><span class="line"><span class="comment">        &quot;not op_mini all&quot;</span></span><br><span class="line"><span class="comment">      ]</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">ident</span>: <span class="string">&#x27;postcss&#x27;</span>, <span class="comment">// 基本写法</span></span><br><span class="line">      <span class="attr">plugins</span>: <span class="function">() =&gt;</span> [</span><br><span class="line">        <span class="comment">// postcss的插件</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)(),</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [...commonCssLoader],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        正常来讲，一个文件只能被一个loader处理</span></span><br><span class="line"><span class="comment">        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序</span></span><br><span class="line"><span class="comment">        先执行eslint再执行babel（用enforce）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          js的语法检查： 需要下载 eslint-loader eslint</span></span><br><span class="line"><span class="comment">          注意：只检查自己写的源代码，第三方的库是不用检查的</span></span><br><span class="line"><span class="comment">          airbnb(一个流行的js风格) --&gt; 需要下载 eslint-config-airbnb-base eslint-plugin-import</span></span><br><span class="line"><span class="comment">          设置检查规则：</span></span><br><span class="line"><span class="comment">            package.json中eslintConfig中设置</span></span><br><span class="line"><span class="comment">              &quot;eslintConfig&quot;: &#123;</span></span><br><span class="line"><span class="comment">                &quot;extends&quot;: &quot;airbnb-base&quot;， // 继承airbnb的风格规范</span></span><br><span class="line"><span class="comment">                &quot;env&quot;: &#123;</span></span><br><span class="line"><span class="comment">                  &quot;browser&quot;: true // 可以使用浏览器中的全局变量(使用window不会报错)</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 忽略node_modules</span></span><br><span class="line">        enforce: <span class="string">&#x27;pre&#x27;</span>, <span class="comment">// 优先执行</span></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 自动修复</span></span><br><span class="line">          <span class="attr">fix</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        js兼容性处理：需要下载 babel-loader @babel/core</span></span><br><span class="line"><span class="comment">          1. 基本js兼容性处理 --&gt; @babel/preset-env</span></span><br><span class="line"><span class="comment">            问题：只能转换基本语法，如promise高级语法不能转换</span></span><br><span class="line"><span class="comment">          2. 全部js兼容性处理 --&gt; @babel/polyfill</span></span><br><span class="line"><span class="comment">            问题：只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了</span></span><br><span class="line"><span class="comment">          3. 需要做兼容性处理的就做：按需加载  --&gt; core-js</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 第三种方式：按需加载</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="comment">// 预设：指示babel做怎样的兼容性处理</span></span><br><span class="line">          <span class="attr">presets</span>: [</span><br><span class="line">            <span class="string">&#x27;@babel/preset-env&#x27;</span>, <span class="comment">// 基本预设</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>, <span class="comment">//按需加载</span></span><br><span class="line">              <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;, <span class="comment">// 指定core-js版本</span></span><br><span class="line">              <span class="attr">targets</span>: &#123; <span class="comment">// 指定兼容到什么版本的浏览器</span></span><br><span class="line">                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span>,</span><br><span class="line">                <span class="attr">ie</span>: <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">                <span class="attr">safari</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">                <span class="attr">edge</span>: <span class="string">&#x27;17&#x27;</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 图片处理</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>, <span class="comment">// 关闭url-loader默认使用的es6模块化解析</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// html中的图片处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 处理其他文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(js|css|less|html|jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// 对输出的css文件进行重命名</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;css/built.css&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimiziCssAssetsWebpackPlugin(),</span><br><span class="line">    <span class="comment">// HtmlWebpackPlugin：html文件的打包和压缩处理</span></span><br><span class="line">    <span class="comment">// 通过这个插件会自动将单独打包的样式文件通过link标签引入</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="comment">// 压缩html代码</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="comment">// 移除空格</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 移除注释</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 生产环境下会自动压缩js代码</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack-优化配置"><a href="#Webpack-优化配置" class="headerlink" title="Webpack 优化配置"></a>Webpack 优化配置</h1><h2 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h2><h3 id="HMR-模块热替换"><a href="#HMR-模块热替换" class="headerlink" title="HMR(模块热替换)"></a>HMR(模块热替换)</h3><p>开启之后，当我们修改了项目代码，webpack 会监听到文件内容的变化，并且重新进行编译等工作，然后会把新的代码通过 websocket 发送给浏览器。浏览器获取到新的代码之后会重新执行模块代码，并且替换模块的内容。这样当一个模块发生变化，只会重新打包构建这一个模块（而不是打包所有模块） ，极大提升构建速度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 开启HMR功能</span></span><br><span class="line">  <span class="comment">// 当修改了webpack配置，新配置要想生效，必须重启webpack服务</span></span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种文件实现热模块替换的情况：</p>
<ul>
<li><p>样式文件：可以使用HMR功能，因为开发环境下使用的 style-loader 内部默认实现了热模块替换功能</p>
</li>
<li><p>js 文件：默认不能使用HMR功能（修改一个 js 模块所有 js 模块都会刷新）</p>
<p>–&gt; 实现 HMR 需要修改 js 代码（添加支持 HMR 功能的代码）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./print.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 方法会监听 print.js 文件的变化，一旦发生变化，只有这个模块会重新打包构建，其他模块不会。</span></span><br><span class="line">    <span class="comment">// 会执行后面的回调函数</span></span><br><span class="line">    print();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件。</p>
</li>
<li><p>html 文件: 默认不能使用 HMR 功能（html 不用做 HMR 功能，因为只有一个 html 文件，不需要再优化）</p>
<p>使用 HMR 会导致问题：html 文件不能热更新了（不会自动打包构建）</p>
<p>解决：修改 entry 入口，将 html 文件引入（这样 html 修改整体刷新）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: [<span class="string">&#x27;./src/js/index.js&#x27;</span>, <span class="string">&#x27;./src/index.html&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>一种提供<strong>源代码到构建后代码的映射</strong>的技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</p>
<p>参数：<code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;eval-source-map&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可选方案：[生成source-map的位置|给出的错误代码信息]</p>
<ul>
<li>source-map：外部，错误代码准确信息 和 源代码的错误位置</li>
<li>inline-source-map：内联，只生成一个内联 source-map，错误代码准确信息 和 源代码的错误位置</li>
<li>hidden-source-map：外部，错误代码错误原因，但是没有错误位置（为了隐藏源代码），不能追踪源代码错误，只能提示到构建后代码的错误位置</li>
<li>eval-source-map：内联，每一个文件都生成对应的 source-map，都在 eval 中，错误代码准确信息 和 源代码的错误位</li>
<li>nosources-source-map：外部，错误代码准确信息，但是没有任何源代码信息（为了隐藏源代码）</li>
<li>cheap-source-map：外部，错误代码准确信息 和 源代码的错误位置，只能把错误精确到整行，忽略列</li>
<li>cheap-module-source-map：外部，错误代码准确信息 和 源代码的错误位置，module 会加入 loader 的 source-map</li>
</ul>
<p>内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</p>
<p>开发/生产环境可做的选择：</p>
<p><strong>开发环境</strong>：需要考虑速度快，调试更友好</p>
<ul>
<li>速度快( eval &gt; inline &gt; cheap &gt;… )<ol>
<li>eval-cheap-souce-map</li>
<li>eval-source-map</li>
</ol>
</li>
<li>调试更友好<ol>
<li>souce-map</li>
<li>cheap-module-souce-map</li>
<li>cheap-souce-map</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; eval-source-map（完整度高，内联速度快） / eval-cheap-module-souce-map（错误提示忽略列但是包含其他信息，内联速度快）</strong></p>
<p><strong>生产环境</strong>：需要考虑源代码要不要隐藏，调试要不要更友好</p>
<ul>
<li>内联会让代码体积变大，所以在生产环境不用内联</li>
<li>隐藏源代码<ol>
<li>nosources-source-map 全部隐藏</li>
<li>hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</li>
</ol>
</li>
</ul>
<p><strong>最终得出最好的两种方案 –&gt; source-map（最完整） / cheap-module-souce-map（错误提示一整行忽略列）</strong></p>
<h2 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h2><h3 id="优化打包构建速度"><a href="#优化打包构建速度" class="headerlink" title="优化打包构建速度"></a>优化打包构建速度</h3><h4 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h4><p>作用：匹配到 loader 后就不再向后进行匹配，优化生产环境的打包构建速度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// js 语法检查</span></span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// 优先执行</span></span><br><span class="line">      enforce: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">fix</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// oneOf 优化生产环境的打包构建速度</span></span><br><span class="line">      <span class="comment">// 以下loader只会匹配一个（匹配到了后就不会再往下匹配了）</span></span><br><span class="line">      <span class="comment">// 注意：不能有两个配置处理同一种类型文件（所以把eslint-loader提取出去放外面）</span></span><br><span class="line">      <span class="attr">oneOf</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [...commonCssLoader]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: [...commonCssLoader, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// js 兼容性处理</span></span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [</span><br><span class="line">              [</span><br><span class="line">                <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">                  <span class="attr">corejs</span>: &#123;<span class="attr">version</span>: <span class="number">3</span>&#125;,</span><br><span class="line">                  <span class="attr">targets</span>: &#123;</span><br><span class="line">                    <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                    <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span>,</span><br><span class="line">            <span class="attr">esModule</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">exclude</span>: <span class="regexp">/\.(js|css|less|html|jpg|png|gif)/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="·-babel缓存"><a href="#·-babel缓存" class="headerlink" title="· babel缓存"></a>· babel缓存</h5><p>作用：类似 HMR，将 babel 处理后的资源缓存起来（哪里的 js 改变就更新哪里，其他 js 还是用之前缓存的资源），让第二次打包构建速度更快。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">          <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">          <span class="attr">targets</span>: &#123;</span><br><span class="line">            <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">            <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 开启babel缓存</span></span><br><span class="line">    <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">    <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h5 id="·-文件资源缓存"><a href="#·-文件资源缓存" class="headerlink" title="· 文件资源缓存"></a>· 文件资源缓存</h5><p>文件名不变，就不会重新请求，而是再次用之前缓存的资源。</p>
<p><strong>1.hash:</strong> 每次 wepack 打包时会生成一个唯一的 hash 值。</p>
<p> 问题：重新打包，所有文件的 hsah 值都改变，会导致所有缓存失效。（可能只改动了一个文件）</p>
<p><strong>2.chunkhash：</strong>根据 chunk 生成的 hash 值。来源于同一个 chunk的 hash 值一样。</p>
<p> 问题：js 和 css 来自同一个chunk，hash 值是一样的（因为 css-loader 会将 css 文件加载到 js 中，所以同属于一个chunk）。</p>
<p><strong>3.contenthash:</strong> 根据文件的内容生成 hash 值。不同文件 hash 值一定不一样(文件内容修改，文件名里的 hash 才会改变)。</p>
<p>修改 css 文件内容，打包后的 css 文件名 hash 值就改变，而 js 文件没有改变 hash 值就不变，这样 css 和 js 缓存就会分开判断要不要重新请求资源 –&gt; 让代码上线运行缓存更好使用。</p>
<h4 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h4><p>某个任务消耗时间较长会卡顿，多进程可以同一时间干多件事，效率更高。</p>
<p>优点是提升打包速度，缺点是每个进程的开启和交流都会有开销（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      thread-loader会对其后面的loader（这里是babel-loader）开启多进程打包。 </span></span><br><span class="line"><span class="comment">      进程启动大概为600ms，进程通信也有开销。(启动的开销比较昂贵，不要滥用)</span></span><br><span class="line"><span class="comment">      只有工作消耗时间比较长，才需要多进程打包</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">workers</span>: <span class="number">2</span> <span class="comment">// 进程2个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">presets</span>: [</span><br><span class="line">          [</span><br><span class="line">            <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">              <span class="attr">corejs</span>: &#123; <span class="attr">version</span>: <span class="number">3</span> &#125;,</span><br><span class="line">              <span class="attr">targets</span>: &#123;</span><br><span class="line">                <span class="attr">chrome</span>: <span class="string">&#x27;60&#x27;</span>,</span><br><span class="line">                <span class="attr">firefox</span>: <span class="string">&#x27;50&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 开启babel缓存</span></span><br><span class="line">        <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">        <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>作用：让某些库不打包，通过 cdn 引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js 中配置：</span></span><br><span class="line"><span class="attr">externals</span>: &#123;</span><br><span class="line">  <span class="comment">// 拒绝jQuery被打包进来(通过cdn引入，速度会快一些)</span></span><br><span class="line">  <span class="comment">// 忽略的库名 -- npm包名</span></span><br><span class="line">  <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在 index.html 中通过 cdn 引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h4><p>作用：让某些库单独打包，后直接引入到 build 中。可以在 code split 分割出 node_modules 后再用 dll 更细的分割，优化代码运行的性能。</p>
<p><em><strong>webpack.dll.js 配置：(将 jquery 单独打包)</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  node_modules的库会打包到一起，但是很多库的时候打包输出的js文件就太大了</span></span><br><span class="line"><span class="comment">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span></span><br><span class="line"><span class="comment">  当运行webpack时，默认查找webpack.config.js配置文件</span></span><br><span class="line"><span class="comment">  需求：需要运行webpack.dll.js文件</span></span><br><span class="line"><span class="comment">    --&gt; webpack --config webpack.dll.js（运行这个指令表示以这个配置文件打包）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 最终打包生成的[name] --&gt; jquery</span></span><br><span class="line">    <span class="comment">// [&#x27;jquery] --&gt; 要打包的库是jquery</span></span><br><span class="line">    <span class="attr">jquery</span>: [<span class="string">&#x27;jquery&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出出口指定</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>, <span class="comment">// name就是jquery</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll&#x27;</span>), <span class="comment">// 打包到dll目录下</span></span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 打包的库里面向外暴露出去的内容叫什么名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 打包生成一个manifest.json --&gt; 提供jquery的映射关系（告诉webpack：jquery之后不需要再打包和暴露内容的名称）</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 映射库的暴露的内容名称</span></span><br><span class="line">      <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>) <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 配置：(告诉 webpack 不需要再打包 jquery，并将之前打包好的 jquery 跟其他打包好的资源一同输出到 build 目录下)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins中配置：</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 告诉webpack哪些库不参与打包，同时使用时的名称也得变</span></span><br><span class="line">  <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    <span class="attr">manifest</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 将某个文件打包输出到build目录下，并在html中自动引入该资源</span></span><br><span class="line">  <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">filepath</span>: resolve(__dirname, <span class="string">&#x27;dll/jquery.js&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="优化代码运行的性能"><a href="#优化代码运行的性能" class="headerlink" title="优化代码运行的性能"></a>优化代码运行的性能</h3><h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h4><p>作用：去除源代码中的无用代码，减少代码体积。</p>
<p>前提：1. 必须使用 ES6 模块化 2. 开启 production 环境 （这样就自动会把无用代码去掉）</p>
<p>在 package.json 中配置：<code>&quot;sideEffects&quot;: false</code> 表示所有代码都没有副作用（都可以进行 tree shaking），这样会导致的问题：可能会把 css / @babel/polyfill 文件干掉（副作用）。</p>
<p>所以可以配置：<code>&quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;]</code> 不会对css/less文件tree shaking处理。</p>
<h4 id="code-split（代码分割）"><a href="#code-split（代码分割）" class="headerlink" title="code split（代码分割）"></a>code split（代码分割）</h4><p>作用：将打包输出的一个大的 bundle.js 文件拆分成多个小文件，这样可以并行加载多个文件，比加载一个文件更快。</p>
<p><strong>module,chunk,bundle区分：</strong><a href="https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html">https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html</a></p>
<h5 id="多入口拆分"><a href="#多入口拆分" class="headerlink" title="多入口拆分"></a>多入口拆分</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="comment">// 多入口：有一个入口，最终输出就有一个bundle</span></span><br><span class="line">    <span class="attr">index</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;./src/js/test.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// [name]：取文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash:10].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h5 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>将 node_modules 中的代码单独打包（大小超过30kb）；</li>
<li>自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk(比如两个模块中都引入了jquery会被打包成单独的文件)（大小超过30kb）。</li>
</ul>
<h5 id="import-动态导入语法"><a href="#import-动态导入语法" class="headerlink" title="import 动态导入语法"></a>import 动态导入语法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  通过js代码，让某个文件被单独打包成一个chunk</span></span><br><span class="line"><span class="comment">  import动态导入语法：能将某个文件单独打包(test文件不会和index打包在同一个文件而是单独打包)</span></span><br><span class="line"><span class="comment">  webpackChunkName:指定test单独打包后文件的名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27; */</span><span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; mul, count &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 文件加载成功~</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;文件加载失败~&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="lazy-loading（懒加载-预加载）"><a href="#lazy-loading（懒加载-预加载）" class="headerlink" title="lazy loading（懒加载/预加载）"></a>lazy loading（懒加载/预加载）</h4><p><strong>1.懒加载：</strong>当文件需要使用时才加载（需要代码分割）。但是如果资源较大，加载时间就会较长，有延迟。</p>
<p><strong>2.正常加载：</strong>可以认为是并行加载（同一时间加载多个文件）没有先后顺序，先加载了不需要的资源就会浪费时间。</p>
<p><strong>3.预加载 prefetch（兼容性很差）：</strong>会在使用之前，提前加载。等其他资源加载完毕，浏览器空闲了，再偷偷加载这个资源。这样在使用时已经加载好了，速度很快。所以在懒加载的基础上加上预加载会更好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将import的内容放在异步回调函数中使用，点击按钮，test.js才会被加载(不会重复加载)</span></span><br><span class="line">  <span class="comment">// webpackPrefetch: true表示开启预加载</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */</span><span class="string">&#x27;./test&#x27;</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./test&#x27;</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="pwa（离线可访问技术）"><a href="#pwa（离线可访问技术）" class="headerlink" title="pwa（离线可访问技术）"></a>pwa（离线可访问技术）</h4><p>使用 serviceworker 和 workbox 技术。优点是离线也能访问，缺点是兼容性差。</p>
<p><em><strong>webpack.config.js 中配置：</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;workbox-webpack-plugin&#x27;</span>); <span class="comment">// 引入插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// plugins中加入：</span></span><br><span class="line"><span class="keyword">new</span> WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 帮助serviceworker快速启动</span></span><br><span class="line"><span class="comment">    2. 删除旧的 serviceworker</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    生成一个 serviceworker 配置文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attr">clientsClaim</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">skipWaiting</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><em><strong>index.js 中还需要写一段代码来激活它的使用：</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. eslint不认识 window、navigator全局变量</span></span><br><span class="line"><span class="comment">    解决：需要修改package.json中eslintConfig配置</span></span><br><span class="line"><span class="comment">    &quot;env&quot;: &#123;</span></span><br><span class="line"><span class="comment">      &quot;browser&quot;: true // 支持浏览器端全局变量</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  2. sw代码必须运行在服务器上</span></span><br><span class="line"><span class="comment">    --&gt; nodejs</span></span><br><span class="line"><span class="comment">    或--&gt;</span></span><br><span class="line"><span class="comment">      npm i serve -g</span></span><br><span class="line"><span class="comment">      serve -s build 启动服务器，将打包输出的build目录下所有资源作为静态资源暴露出去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123; <span class="comment">// 处理兼容性问题</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">&#x27;/service-worker.js&#x27;</span>) <span class="comment">// 注册serviceWorker</span></span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册成功了~&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册失败了~&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Webpack配置详情"><a href="#Webpack配置详情" class="headerlink" title="Webpack配置详情"></a>Webpack配置详情</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry: 入口起点</p>
<ol>
<li><p>string –&gt; ‘./src/index.js’，单入口</p>
<p>打包形成一个 chunk。 输出一个 bundle 文件。此时 chunk 的名称默认是 main</p>
</li>
<li><p>array –&gt; [‘./src/index.js’, ‘./src/add.js’]，多入口</p>
<p>所有入口文件最终只会形成一个 chunk，输出出去只有一个 bundle 文件。</p>
<p>（一般只用在 HMR 功能中让 html 热更新生效）</p>
</li>
<li><p>object，多入口</p>
<p>有几个入口文件就形成几个 chunk，输出几个 bundle 文件，此时 chunk 的名称是 key 值</p>
</li>
</ol>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  <span class="comment">// 文件名称（指定名称+目录）</span></span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;js/[name].js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出文件目录（将来所有资源输出的公共目录）</span></span><br><span class="line">  <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="comment">// 所有资源引入公共路径前缀 --&gt; &#x27;imgs/a.jpg&#x27; --&gt; &#x27;/imgs/a.jpg&#x27;</span></span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">chunkFilename</span>: <span class="string">&#x27;js/[name]_chunk.js&#x27;</span>, <span class="comment">// 指定非入口chunk的名称</span></span><br><span class="line">  <span class="attr">library</span>: <span class="string">&#x27;[name]&#x27;</span>, <span class="comment">// 打包整个库后向外暴露的变量名</span></span><br><span class="line">  <span class="attr">libraryTarget</span>: <span class="string">&#x27;window&#x27;</span> <span class="comment">// 变量名添加到哪个上 browser：window</span></span><br><span class="line">  <span class="comment">// libraryTarget: &#x27;global&#x27; // node：global</span></span><br><span class="line">  <span class="comment">// libraryTarget: &#x27;commonjs&#x27; // conmmonjs模块 exports</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    <span class="comment">// loader的配置</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 多个loader用use</span></span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="comment">// 排除node_modules下的js文件</span></span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// 只检查src下的js文件</span></span><br><span class="line">      include: resolve(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>, <span class="comment">// 优先执行</span></span><br><span class="line">      <span class="comment">// enforce: &#x27;post&#x27;, // 延后执行</span></span><br><span class="line">      <span class="comment">// 单个loader用loader</span></span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;&#125; <span class="comment">// 指定配置选项</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 以下配置只会生效一个</span></span><br><span class="line">      <span class="attr">oneOf</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析模块的规则</span></span><br><span class="line"><span class="attr">resolve</span>: &#123;</span><br><span class="line">  <span class="comment">// 配置解析模块路径别名: 优点：当目录层级很复杂时，简写路径；缺点：路径不会提示</span></span><br><span class="line">  <span class="attr">alias</span>: &#123;</span><br><span class="line">    <span class="attr">$css</span>: resolve(__dirname, <span class="string">&#x27;src/css&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置省略文件路径的后缀名（引入时就可以不写文件后缀名了）</span></span><br><span class="line">  <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>],</span><br><span class="line">  <span class="comment">// 告诉 webpack 解析模块应该去找哪个目录</span></span><br><span class="line">  <span class="attr">modules</span>: [resolve(__dirname, <span class="string">&#x27;../../node_modules&#x27;</span>), <span class="string">&#x27;node_modules&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样配置后，引入文件就可以这样简写：<code>import &#39;$css/index&#39;;</code></p>
<h2 id="dev-server"><a href="#dev-server" class="headerlink" title="dev server"></a>dev server</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 运行代码所在的目录</span></span><br><span class="line">  <span class="attr">contentBase</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="comment">// 监视contentBase目录下的所有文件，一旦文件变化就会reload</span></span><br><span class="line">  <span class="attr">watchContentBase</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">watchOptions</span>: &#123;</span><br><span class="line">    <span class="comment">// 忽略文件</span></span><br><span class="line">    <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 启动gzip压缩</span></span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 端口号</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="comment">// 域名</span></span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="comment">// 自动打开浏览器</span></span><br><span class="line">  <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 开启HMR功能</span></span><br><span class="line">  <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 不要显示启动服务器日志信息</span></span><br><span class="line">  <span class="attr">clientLogLevel</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="comment">// 除了一些基本信息外，其他内容都不要显示</span></span><br><span class="line">  <span class="attr">quiet</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 如果出错了，不要全屏提示</span></span><br><span class="line">  <span class="attr">overlay</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 服务器代理，--&gt; 解决开发环境跨域问题</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="comment">// 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到另外一个服务器3000</span></span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">      <span class="comment">// 发送请求时，请求路径重写：将/api/xxx --&gt; /xxx （去掉/api）</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="optimization-1"><a href="#optimization-1" class="headerlink" title="optimization"></a>optimization</h2><p>contenthash 缓存会导致一个问题：修改 a 文件导致 b 文件 contenthash 变化。<br>因为在 index.js 中引入 a.js，打包后 index.js 中记录了 a.js 的 hash 值，而 a.js 改变，其重新打包后的 hash 改变，导致 index.js 文件内容中记录的 a.js 的 hash 也改变，从而重新打包后 index.js 的 hash 值也会变，这样就会使缓存失效。（改变的是a.js文件但是 index.js 文件的 hash 值也改变了）<br>解决办法：runtimeChunk –&gt; 将当前模块记录其他模块的 hash 单独打包为一个文件 runtime，这样 a.js 的 hash 改变只会影响 runtime 文件，不会影响到 index.js 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;js/[name].[contenthash:10].js&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  <span class="attr">chunkFilename</span>: <span class="string">&#x27;js/[name].[contenthash:10]_chunk.js&#x27;</span> <span class="comment">// 指定非入口文件的其他chunk的名字加_chunk</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 以下都是splitChunks默认配置，可以不写</span></span><br><span class="line"><span class="comment">    miniSize: 30 * 1024, // 分割的chunk最小为30kb（大于30kb的才分割）</span></span><br><span class="line"><span class="comment">    maxSize: 0, // 最大没有限制</span></span><br><span class="line"><span class="comment">    minChunks: 1, // 要提取的chunk最少被引用1次</span></span><br><span class="line"><span class="comment">    maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量为5</span></span><br><span class="line"><span class="comment">    maxInitialRequests: 3, // 入口js文件最大并行请求数量</span></span><br><span class="line"><span class="comment">    automaticNameDelimiter: &#x27;~&#x27;, // 名称连接符</span></span><br><span class="line"><span class="comment">    name: true, // 可以使用命名规则</span></span><br><span class="line"><span class="comment">    cacheGroups: &#123; // 分割chunk的组</span></span><br><span class="line"><span class="comment">      vendors: &#123;</span></span><br><span class="line"><span class="comment">        // node_modules中的文件会被打包到vendors组的chunk中，--&gt; vendors~xxx.js</span></span><br><span class="line"><span class="comment">        // 满足上面的公共规则，大小超过30kb、至少被引用一次</span></span><br><span class="line"><span class="comment">        test: /[\\/]node_modules[\\/]/,</span></span><br><span class="line"><span class="comment">        // 优先级</span></span><br><span class="line"><span class="comment">        priority: -10</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      default: &#123;</span></span><br><span class="line"><span class="comment">        // 要提取的chunk最少被引用2次</span></span><br><span class="line"><span class="comment">        minChunks: 2,</span></span><br><span class="line"><span class="comment">        prority: -20,</span></span><br><span class="line"><span class="comment">        // 如果当前要打包的模块和之前已经被提取的模块是同一个，就会复用，而不是重新打包</span></span><br><span class="line"><span class="comment">        reuseExistingChunk: true</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 将index.js记录的a.js的hash值单独打包到runtime文件中</span></span><br><span class="line">  <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="function"><span class="params">entrypoint</span> =&gt;</span> <span class="string">`runtime-<span class="subst">$&#123;entrypoint.name&#125;</span>`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">minimizer</span>: [</span><br><span class="line">    <span class="comment">// 配置生产环境的压缩方案：js/css</span></span><br><span class="line">    <span class="keyword">new</span> TerserWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 开启多进程打包</span></span><br><span class="line">      <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 启用sourceMap(否则会被压缩掉)</span></span><br><span class="line">      <span class="attr">sourceMap</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>资源构建打包工具</category>
      </categories>
      <tags>
        <tag>打包工具</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器基本工作原理(一)</title>
    <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本文主要记录一下最近重温的网络传输和浏览器的一些基本工作原理以及工作流程等知识。主要参考了李兵老师的《浏览器工作原理与实践》。本文只介绍到响应数据返回给浏览器之前的工作流程，之后的工作在下一篇文章。</p>
<span id="more"></span>

<h3 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="headerlink" title="浏览器的多进程架构"></a>浏览器的多进程架构</h3><p>早期的浏览器是单进程架构，即<strong>浏览器的所有功能模块都是运行在同一个进程里</strong>，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。但是会有如下的一些问题：</p>
<ol>
<li><p><strong>不稳定</strong></p>
<p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。</p>
</li>
<li><p><strong>不流畅</strong></p>
<p>所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。如果JS中出现了死循环的情况，那么就会独占线程，其他模块没有机会被执行。</p>
</li>
</ol>
<p>基于上述问题，目前的Chrome采用的是如下的多进程架构：</p>
<img src="https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png" alt="组件层级示例" style="zoom:50%;" />

<p>各个进程的基本功能如下：</p>
<p><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p>
<p><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
<p><strong>GPU 进程</strong>：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>
<p><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>
<p>所以当我们打开一个页面的时候，至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<h3 id="TCP-IP-amp-HTTP"><a href="#TCP-IP-amp-HTTP" class="headerlink" title="TCP/IP&amp;HTTP"></a>TCP/IP&amp;HTTP</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP是一种<strong>面向连接的、可靠的、基于字节流的传输层通信协议</strong>。相比较于UDP，TCP对于数据包丢失的情况提供重传机制，并且引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p>
<p>单个数据包流程如下：</p>
<img src="https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png" alt="组件层级示例" style="zoom:50%;" />

<p>IP头中包括了IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息，TCP头中包含了源端口号，目标端口号等，用于把数据部分交给上层应用程序。那么TCP是如何保证可靠性的呢？</p>
<p><strong>首先，建立连接阶段</strong>。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。</p>
<p><strong>其次，传输数据阶段</strong>。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。</p>
<p><strong>最后，断开连接阶段</strong>。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。</p>
<p><strong>总结就是</strong>：TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。</p>
<p>而上图中的上层，即为<strong>应用层</strong>，浏览器使用HTTP作为应用层协议，可以说HTTP 协议是建立在 TCP 连接基础之上的。</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="浏览器端发起-HTTP-请求流程"><a href="#浏览器端发起-HTTP-请求流程" class="headerlink" title="浏览器端发起 HTTP 请求流程"></a>浏览器端发起 HTTP 请求流程</h5><p>当我们在浏览器地址栏输入一串地址，浏览器是如何工作的呢？</p>
<ol>
<li><p><strong>构建请求</strong></p>
<p>首先，浏览器构建请求行信息，构建好后，浏览器准备发起网络请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP1<span class="number">.1</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>查找缓存</strong></p>
<p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。</p>
<p>如果缓存查找失败，就会进入网络请求过程。</p>
</li>
<li><p><strong>准备IP地址和端口</strong></p>
<p>因为浏览器使用 HTTP 协议作为应用层协议，<strong>用来封装请求的文本信息</strong>；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，</p>
</li>
</ol>
<img src="https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png" alt="组件层级示例" style="zoom:50%;" />

<p>​        所以HTTP网络请求第一步应该是建立TCP连接，而建立连接需要获取IP地址和端口号，HTTP默认端口号是80，而IP地址需要DNS来        进行域名解析。浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时        直接使用，这样也会减少一次网络请求。</p>
<ol start="4">
<li><p><strong>等待TCP队列</strong></p>
<p>此时IP地址和端口号已经准备好，但是并不意味着可以立马进行TCP连接。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p>
<p>http/1.1 一个tcp同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！ 但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求。 不过http2是可以并行请求资源的，所以如果使用http2，浏览器只会为每个域名维护一个tcp连接。（<strong>此处没有深究</strong>）</p>
<p>如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p>
</li>
<li><p><strong>建立TCP连接</strong></p>
</li>
<li><p><strong>发送HTTP请求</strong></p>
<p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p>
</li>
</ol>
<img src="https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png" alt="组件层级示例" style="zoom:50%;" />

<p>​    首先浏览器会向服务器发送<strong>请求行</strong>，它包括了<strong>请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议</strong>。如果使用     POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过<strong>请求体</strong>来发送。</p>
<p>​    在浏览器发送请求行命令之后，还要以<strong>请求头</strong>形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用    的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p>
<h5 id="服务器端处理-HTTP-请求流程"><a href="#服务器端处理-HTTP-请求流程" class="headerlink" title="服务器端处理 HTTP 请求流程"></a>服务器端处理 HTTP 请求流程</h5><ol>
<li><p><strong>返回请求</strong></p>
<img src="https://static001.geekbang.org/resource/image/3e/76/3e30476a4bbda49fd7cd4fd0ea09f076.png" alt="组件层级示例" style="zoom:50%;" />

<p>首先服务器会返回响应行，包括协议版本和状态码。随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</p>
</li>
<li><p><strong>断开连接</strong></p>
<p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure>

<p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。<strong>保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</strong>。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p>
</li>
<li><p><strong>重定向</strong></p>
<p>如果响应行返回的状态码是301,则是告诉浏览器需要重定向到另外一个网址，而需要重定向的网址包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航。</p>
</li>
</ol>
<h4 id="总结HTTP请求"><a href="#总结HTTP请求" class="headerlink" title="总结HTTP请求"></a>总结HTTP请求</h4><img src="https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png" alt="组件层级示例" style="zoom:50%;" />

<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><h5 id="站点第二次打开速度很快的原因"><a href="#站点第二次打开速度很快的原因" class="headerlink" title="站点第二次打开速度很快的原因"></a>站点第二次打开速度很快的原因</h5><p>如果第二次页面打开很快，主要原因是<strong>第一次加载页面过程中，缓存了一些耗时的数据</strong>。DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。浏览器资源缓存的处理过程大致如下：</p>
<img src="https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png" alt="组件层级示例" style="zoom:40%;" />

<p>第一次请求，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的。即在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器，不会进行网络请求。</p>
<p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">If-None-Match:<span class="string">&quot;4f80f-13c-3a1xb12a&quot;</span></span><br></pre></td></tr></table></figure>

<p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了; ”如果资源有更新，服务器就直接返回最新资源给浏览器。(<strong>关于浏览器缓存的细节比较多，这里只是简单概括</strong>)</p>
<h5 id="登录状态如何保持？"><a href="#登录状态如何保持？" class="headerlink" title="登录状态如何保持？"></a>登录状态如何保持？</h5><ol>
<li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</li>
<li>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，然后把响应头发送给浏览器。</li>
<li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。</li>
<li>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</li>
<li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li>
<li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息。</li>
</ol>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器基本原理</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器基本工作原理(二)</title>
    <url>/%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>本文主要从浏览器进程角度来梳理一下在浏览器里，从输入 URL 到页面展示，这中间发生的一系列事情。</p>
<span id="more"></span>

<h3 id="从输入-URL-到页面展示完整流程示意图"><a href="#从输入-URL-到页面展示完整流程示意图" class="headerlink" title="从输入 URL 到页面展示完整流程示意图"></a>从输入 URL 到页面展示完整流程示意图</h3><img src="https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png" alt="组件层级示例" style="zoom:50%;" />

<p>这个过程可以大概描述如下：</p>
<ol>
<li>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。</li>
<li>然后，在网络进程中发起真正的 URL 请求。</li>
<li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</li>
<li>浏览器进程接收到网络进程的响应头数据之后，发送<strong>“提交导航 (CommitNavigation)”消息</strong>到渲染进程；</li>
<li>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</li>
<li>最后渲染进程会向浏览器进程<strong>“确认提交”</strong>，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</li>
<li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</li>
</ol>
<p><strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。</strong></p>
<ol>
<li><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</p>
<p>​    <strong>·</strong> 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</p>
<p>​    <strong>·</strong> 如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。</p>
<p>当用户输入关键字并键入回车之后，意味着当前页面即将要被替换成新的页面，不过之前浏览器还给了当前页面一次执行<strong>beforeunload 事件</strong>的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。</p>
<p>当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时页面显示的依然是之前打开的页面内容，并没立即替换为新请求的页面。因为<strong>需要等待提交文档阶段，页面内容才会被替换</strong>。</p>
</li>
<li><h4 id="URL请求过程"><a href="#URL请求过程" class="headerlink" title="URL请求过程"></a>URL请求过程</h4><p>这个在上一篇文章中有写过，主要就是浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</p>
<p>需要注意响应头中的Content-Type字段，比如如果 Content-Type 字段的值被浏览器判断为下载类型，<strong>那么该请求会被提交给浏览器的下载管理器，并且该 URL 请求的导航流程就此结束</strong>。但<strong>如果是 HTML，那么浏览器则会继续进行导航流程</strong>。在Chrome中，接下来就需要准备渲染进程了。</p>
</li>
<li><h4 id="准备渲染进程"><a href="#准备渲染进程" class="headerlink" title="准备渲染进程"></a>准备渲染进程</h4><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>
<p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p>
<p>结论是：**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程( process-per-site-instance)**。</p>
<p><strong>同一站点：</strong> <strong>根域名</strong>（例如，geekbang.org）加上<strong>协议</strong>（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口。</p>
<p>如果新页面和当前页面不属于同一站点，浏览器会使用一个新的渲染进程。</p>
<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p>
</li>
<li><h4 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h4><p>提交文档是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程。具体流程大概如下：</p>
<p><strong>·</strong> 首先当浏览器进程接收到网络进程的响应头数据之后，便<strong>向渲染进程发起“提交文档”的消息</strong>；</p>
<p><strong>·</strong> 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”;</p>
<p><strong>·</strong> 等文档数据传输完成之后，渲染进程会返回“<strong>确认提交</strong>”的消息给浏览器进程；</p>
<p><strong>·</strong> 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新           Web 页面。</p>
<p>当渲染进程<strong>确认提交</strong>之后，更新的页面如下：</p>
<img src="https://static001.geekbang.org/resource/image/d3/b8/d3c5a6188b09b5b57af439005ae7dfb8.png" alt="组件层级示例" style="zoom:50%;" /></li>
</ol>
<p>所以在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p>
<ol start="5">
<li><h4 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h4></li>
</ol>
<p>一旦文档被提交，渲染进程便开始页面解析和子资源加载，<strong>具体渲染流程比较复杂，之后再来进行总结</strong>。一旦页面生成完毕，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器基本原理</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存</title>
    <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>本文主要记录一下浏览器缓存相关知识，主要涉及知识点包括强缓存，协商缓存等，最后会简单理一下DNS流程和CDN缓存。</p>
<span id="more"></span>

<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>其实web缓存分为很多种，比如CDN缓存，DNS缓存，浏览器缓存等。本文主要是总结下浏览器缓存的相关细节。在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。所以<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong>。它会在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。这样访问过的资源可以从浏览器缓存中拿出使用。通过减少服务器处理请求的数量，用户将获得更快的体验。</p>
<p>浏览器缓存分为：<strong>强缓存，协商缓存。</strong></p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。</p>
<p>这里的 header 中的信息指的是 <strong>expires 和 cache-control.</strong></p>
<ol>
<li><p><strong>Cache-Control:</strong></p>
<p>Cache-Control包括：</p>
<ul>
<li>max-age</li>
<li>s-maxage</li>
<li>public</li>
<li>private</li>
<li>no-cache</li>
<li>no-store</li>
<li>must-revalidate</li>
</ul>
<p><strong><code>max-age</code>（单位为s）指定设置缓存最大的有效时间，定义的是时间长短</strong>。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了。即使服务器上的资源发生了变化，浏览器也不会得到通知。</p>
<p><strong><code>s-maxage</code>（单位为s）同max-age，只用于共享缓存（比如CDN缓存）。</strong><br>比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通缓存，而s-maxage用于代理缓存。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p>
<p><strong><code>public</code> 指定响应会被缓存，并且在多用户间共享</strong>。也就是下图的意思。如果没有指定public还是private，则默认为public。</p>
<img src="https://segmentfault.com/img/bVJjuK" style="zoom:90%;" /></li>
</ol>
<p>​        <strong><code>private</code> 响应只作为私有的缓存，不能在用户间共享</strong>。如果要求HTTP认证，响应会自动设置为private。</p>
<p>​        <strong><code>no-cache</code> 指定不缓存响应，表明资源不进行缓存</strong>。</p>
<img src="https://segmentfault.com/img/bVJjuQ" style="zoom:90%;" />

<p>​        但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。</p>
<p>​        <strong><code>no-store</code> 绝对禁止缓存</strong>。每次请求资源都要从服务器重新获取。<br>​        <strong><code>must-revalidate</code>指定如果页面是过期的，则去服务器进行获取</strong>。这个指令并不常用，就不做过多的讨论了。</p>
<ol start="2">
<li><strong>Expires</strong></li>
</ol>
<p>​        缓存过期时间，用来指定资源到期的时间，是<strong>服务器端的具体的时间点</strong>。比cache-control优先级低。该字段是 <strong>http1.0</strong> 时的规范，它的值为一个<strong>绝对时间</strong>的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，<strong>由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</strong></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 <strong>304</strong> ，告诉浏览器资源未更新，可使用本地的缓存。</p>
<p>这里的 header 中的信息指的是<strong>Last-Modify/If-Modify-Since 和 ETag/If-None-Match。</strong></p>
<ol>
<li><strong>Last-modified</strong></li>
</ol>
<p>​    服务器端文件的最后修改时间，需要和<code>cache-control</code>共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送<code>If-Modified-Since</code>报头，询问<code>Last-Modified</code>时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。</p>
<img src="https://segmentfault.com/img/bVJjvF"  style="zoom:90%;" />

<ol start="2">
<li><p><strong>ETag</strong></p>
<p>根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下：</p>
<img src="https://segmentfault.com/img/bVJjv8" style="zoom:80%;" /></li>
</ol>
<p><strong>Last-modified和ETag比较</strong></p>
<p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ol>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。</li>
</ol>
<p>也就是说：</p>
<ol>
<li>Last-Modified是<strong>根据文件的修改时间</strong>作唯一标示，并且修改时间只能精确到秒级（同1s修改多次，无法生成新的Last-Modified）。</li>
<li>Etag是<strong>根据资源内容</strong>在服务器端的唯一标识符，能够更加准确的控制缓存。</li>
</ol>
<p>Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag</strong>，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<h4 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h4><img src="https://segmentfault.com/img/bVJjwd"  style="zoom:90%;" />



<h4 id="缓存实现方式"><a href="#缓存实现方式" class="headerlink" title="缓存实现方式"></a>缓存实现方式</h4><p><strong>方式一：客户端指定</strong></p>
<ol>
<li>request header 携带cache-control。</li>
<li>服务端接收到 header cache-control字段，并且使用该字段设置response 的 cache-control。</li>
<li>浏览器接收到response header,根据cache-control 设置缓存。</li>
</ol>
<p><strong>方法二：服务端指定</strong></p>
<ol>
<li>服务端接收到请求，设置response 的 cache-control并返回response。</li>
<li>浏览器接收到response header,根据cache-control 设置缓存。</li>
</ol>
<h4 id="缓存的资源在哪里？"><a href="#缓存的资源在哪里？" class="headerlink" title="缓存的资源在哪里？"></a>缓存的资源在哪里？</h4><ol>
<li><strong>memory cache</strong></li>
</ol>
<p>​    内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>
<ol start="2">
<li><strong>Disk Cache</strong></li>
</ol>
<p>​    存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p>
<p>​    在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。</p>
<ol start="3">
<li><strong>Service Worker</strong></li>
</ol>
<p>​    是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>
<ol start="4">
<li><strong>prefetch cache(预取缓存)</strong></li>
</ol>
<p>​    link标签上带了prefetch，再次加载会出现。<code>prefetch</code> 在浏览器空闲时间下载或预取用户在不久的将来可能访问的文档，在当前的页面加载完成后预取资源放进缓存中，在之后的调用就直接从缓存中获取，从而提升性能。</p>
<p>查找浏览器缓存时会按顺序查找: <strong>Service Worker–&gt;Memory Cache–&gt;Disk Cache–&gt;Push Cache。</strong></p>
<h4 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h4><p>目前的项目大多使用这种缓存方案的：</p>
<ul>
<li>HTML: 协商缓存；</li>
<li>css、js、图片：强缓存，文件名带上hash。</li>
</ul>
<h4 id="刷新对于强缓存和协商缓存的影响"><a href="#刷新对于强缓存和协商缓存的影响" class="headerlink" title="刷新对于强缓存和协商缓存的影响"></a>刷新对于强缓存和协商缓存的影响</h4><ol>
<li><p>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</p>
</li>
<li><p>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</p>
</li>
<li><p>浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</p>
</li>
</ol>
<h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>DNS解析：通过域名,最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。</p>
<p>DNS查询过程如下:</p>
<ol>
<li>首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。</li>
<li>如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。</li>
<li>如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。</li>
</ol>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>cdn:即内容分发网络。看到过一个形象的比喻来理解CDN是什么。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">10年前，还没有火车票代售点一说，12306.cn更是无从说起。那时候火车票还只能在火车站的售票大厅购买，而我所在的小县城并不通火车，火车票都要去市里的火车站购买，而从我家到县城再到市里，来回就是4个小时车程，简直就是浪费生命。后来就好了，小县城里出现了火车票代售点，甚至乡镇上也有了代售点，可以直接在代售点购买火车票，方便了不少，全市人民再也不用在一个点苦逼的排队买票了。</span><br></pre></td></tr></table></figure>

<p>简单的理解CDN就是这些代售点(缓存服务器)的承包商,他为买票者提供了便利,帮助他们在最近的地方(最近的CDN节点)用最短的时间(最短的请求时间)买到票(拿到资源),这样去火车站售票大厅排队的人也就少了。也就减轻了售票大厅的压力(起到分流作用,减轻服务器负载压力)。</p>
<p>用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。</p>
<p>关于CDN缓存,在浏览器本地缓存失效后,浏览器会向CDN边缘节点发起请求。类似浏览器缓存,CDN边缘节点也存在着一套缓存机制。CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的Cache-control: max-age的字段来设置CDN边缘节点数据缓存时间。</p>
<p>当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
]]></content>
      <categories>
        <category>浏览器</category>
        <category>缓存手段</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
</search>
